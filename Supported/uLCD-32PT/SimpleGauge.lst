4DGL Compiler 2.6.0.4 -- Copyright 2004-2010 4D Labs
** C:\Users\Ian\Documents\ms-can-display\ms-can-display\Supported\uLCD-32PT\SimpleGauge.4DG compiled Sat Jul  2 16:22:23 2011

file C:\Users\Ian\Documents\ms-can-display\ms-can-display\Supported\uLCD-32PT\SimpleGauge.4DG

file C:\Program Files (x86)\4D Labs\4D Workshop 3 IDE\include\uLCD-32PT_GFX2.fnc

0001  0001             #platform "uLCD-32PT_GFX2"
0002  0001             #platform "uLCD-32PT_GFX2"
0003  0008             */
0004  0009                 #constant ULCD_32PT_GFX
0005  0009                 #constant ULCD_32PT_GFX
0006  0010   
0007  0011                 #IFNOT EXISTS PICASO_GFX2_FUNCTIONS
file C:\Program Files (x86)\4D Labs\4D Workshop 3 IDE\include\PicasoGFX2_Functions.fnc

0008  0012                     #inherit "PicasoGFX2_Functions.fnc"          // inherit the generic functions
0009  0012                     #inherit "PicasoGFX2_Functions.fnc"          // inherit the generic functions
0010  0001   
0011  0002             // Common inheritance for PicasoGFX2 platforms
0012  0003   
0013  0004             #constant PICASO_GFX_FUNCTIONS
0014  0004             #constant PICASO_GFX_FUNCTIONS
0015  0005   
0016  0006   
0017  0007             #CONST
0018  0017             #END
0019  0018   
0020  0019             #CONST
0021  0025             #END
0022  0026   
0023  0027   
0024  0028             #CONST
0025  0040             #END
0026  0041   
0027  0042   
0028  0043             #CONST
0029  0208             #END
0030  0209   
0031  0210   
0032  0211             // baud divisor rates for setbaud(n);
0033  0212             #CONST
0034  0234             #END
0035  0235   
0036  0236   
0037  0237   
0038  0238   
0039  0243             */
0040  0244   
0041  0245   
0042  0246             //==============================================//
0043  0247             // EVE bios functions                           //
0044  0248             //==============================================//
0045  0249                                                             //
0046  0250             func serin(), 1;                // read a byte from COM0
0047  0251             // Syntax: serin();
0048  0252             // Usage : char := serin();
0049  0253             // Notes : Receives a character from the Serial Port COM0. The transmission format is:
0050  0254             //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
0051  0255             //     : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
0052  0256             //     : changed under program control by using the setbaud(...) or the com_SetBaud(...) function.
0053  0257             //     : Returns: -1 if no character is available
0054  0258             //     : Returns: -2 if a framing error or over-run has occurred (auto cleared)
0055  0259             //     : Returns: positive value 0 to 255 for a valid character received
0056  0260   
0057  0261             func putch("char"), 0;                // write single char to current output device
0058  0262             // Syntax: putch("char");
0059  0263             // Usage : putch("A");
0060  0264             // Notes : Transmits a single byte from the Serial Port COM0. The transmission format is:
0061  0265             //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
0062  0266             //     : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
0063  0267             //     : changed under program control by using the setbaud(...) or the com_SetBaud(...) function.
0064  0268             //     : The arguments can be a variable, array element, expression or constant
0065  0269   
0066  0270             func serout("char"), 0;                // write a byte to COM0
0067  0271             // Syntax: serout1("char");
0068  0272             // Usage : serout1(ch);
0069  0273             // Notes : send character to COM1
0070  0274   
0071  0275             func setbaud("baudnum"), 0;            // set baud rate of COM0
0072  0276             // Syntax: setbaud(baud_number);
0073  0277             // Usage : setbaud(BAUD_128000);        //Set baud rate to 128000bps
0074  0278             // *Notes : argument specifies the baud rate using pre-defined constant.
0075  0279             //       : The pre-defined constant is a value of 0-19 , and internally
0076  0280             //       : this is used as a table pointer to get the baud rate divisor
0077  0281             //       : value for one of the 20 selected baud rates, control is then
0078  0282             //       : passed to com_SetBaud(COM0, baudlookup[baud_number]);
0079  0283             //       : The pre-defined constants equate to a value of 0-19.
0080  0284             //       : If a value other than 0-19 is used, a run time error (eror 25)
0081  0285             //       : will occur.
0082  0286   
0083  0287             func to("device"), 1;                // output device redirection
0084  0288             // Syntax: to(outstream);
0085  0289             // Usage : to(APPEND); putstr("TWO ");
0086  0290             // Notes : outstream: A variable or constant specifying destination for putch, putstr, putnum and print functions.
0087  0291             //     :
0088  0292             //     : to() sends the printed output to destinations other than the screen. Normally, print just
0089  0293             //     : sends its output to the display in TEXT mode which is the default, however, the output from
0090  0294             //     : print can be sent to COM0, and MDA (media) 'streams'. The to(...) function can also stream
0091  0295             //     : to a memory array . Note that once the to(...) function has taken effect, the stream reverts
0092  0296             //     : back to the default stream which is TEXT as soon as putch, putstr, putnum or print has
0093  0297             //     : completed its action. The APPEND argument is used to send the printed output to the same
0094  0298             //     : place as the previous redirection. This is most useful for building string arrays, or adding
0095  0299             //     : sequential data to a media stream.
0096  0300             //     :
0097  0301             //     : Predefined Name Constant    putch(), putstr(), putnum(), print() redirection
0098  0302             //     : APPEND         0x0000      Output is directed to the same stream that was previously assigned. Output is
0099  0303             //     :                            appended to user memory if previous redirection was to an array.
0100  0304             //     : COM0           0xFF04      Output is redirected to the COM (serial) port.
0101  0305             //     : TEXT           0xFF08      Output is directed to the screen (default).
0102  0306             //     : MDA            0xFF10      Output is directed to the SD or FLASH media.
0103  0307             //     : I2C            0xF820      Output is directed to the I2C port.
0104  0308             //     : memory pointer             Output is redirect to the memory pointer argument, eg to(myarray); print("HELLO");
0105  0309   
0106  0310   
0107  0311             func pause("milliseconds"), 0;            // blocking delay
0108  0312             // Syntax: pause(milliseconds);
0109  0313             // Usage : pause(1000);                //pause for 1 second
0110  0314             // Notes : Pause for a number of milli second.Maximum delay could be 65535 milli seconds
0111  0315   
0112  0316             func putnum("arg1","arg2"), 1;            // print number to current output device
0113  0317             // Syntax: putnum(format, value);
0114  0318             // Usage : var := putnum(HEX, val);
0115  0319             // Notes : prints a 16bit number in various formats to the current output stream, usually the display.
0116  0320             //     : Format: A constant that specifies the number format
0117  0321             //     : Value : The number to be printed
0118  0322             //     : (      DECIMAL   )    (   UNSIGNED DECIMAL )    (    HEX         )     (    BINARY          )
0119  0323             //     : DEC     DECZ     DECZB     UDEC     UDECZ     UDECZB     HEX     HEXZ     HEXZB     BIN     BINZ     BINZB
0120  0324             //     : DEC1 DEC1Z     DEC1ZB     UDEC1     UDEC1Z     UDEC1ZB HEX1     HEX1Z     HEX1ZB     BIN1     BIN1Z     BIN1ZB
0121  0325             //     : DEC2 DEC2Z     DEC2ZB     UDEC2     UDEC2Z     UDEC2ZB HEX2     HEX2Z     HEX1ZB     BIN2     BIN2Z     BIN2ZB
0122  0326             //     : DEC3 DEC3Z     DEC3ZB     UDEC3     UDEC3Z     UDEC3ZB HEX3     HEX3Z     HEX1ZB     BIN3     BIN3Z     BIN3ZB
0123  0327             //     : DEC4 DEC4Z     DEC4ZB     UDEC4     UDEC4Z     UDEC4ZB HEX4     HEX4Z     HEX1ZB     BIN4     BIN4Z     BIN4ZB
0124  0328             //     : DEC5 DEC5Z     DEC5ZB     UDEC5     UDEC5Z     UDEC5ZB             BIN5     BIN5Z     BIN5ZB
0125  0329             //     :                                     BIN6     BIN6Z     BIN6ZB
0126  0330             //     :                                     BIN7     BIN7Z     BIN7ZB
0127  0331             //     :                                     BIN8     BIN8Z     BIN8ZB
0128  0332             //     :                                     BIN9     BIN9Z     BIN9ZB
0129  0333             //     :                                     BIN10     BIN10Z     BIN10ZB
0130  0334             //     :                                     BIN11     BIN11Z     BIN11ZB
0131  0335             //     :                                     BIN12     BIN12Z     BIN12ZB
0132  0336             //     :                                     BIN13     BIN13Z     BIN13ZB
0133  0337             //     :                                     BIN14     BIN14Z     BIN14ZB
0134  0338             //     :                                     BIN15     BIN15Z     BIN15ZB
0135  0339             //     :                                     BIN16     BIN16Z     BIN16ZB
0136  0340             //     : field: Returns the the default width of the numeric field (digit count), usually ignored.
0137  0341             //     : bit 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
0138  0342             //     : | | | | \___ ___/ \__ __/ \_____ _____/
0139  0343             //     : | | | | V V V
0140  0344             //     : | | | | | | |
0141  0345             //     : | | | | | |
0142  0346             //     : | | | | (nb 0 = 16) | |____BASE (usually 2,10 or 16)
0143  0347             //     : | | | | digit count |
0144  0348             //     : | | | | |___reserved (not used on GOLDELOX)
0145  0349             //     : | | | |
0146  0350             //     : | | | |
0147  0351             //     : | | | |
0148  0352             //     : | | | |
0149  0353             //     : | | | |
0150  0354             //     : | | | |______ 1 = leading zeros included
0151  0355             //     : | | | 0 = leading zeros suppressed
0152  0356             //     : | | |
0153  0357             //     : | | |
0154  0358             //     : | | |_______ 1 = leading zero blanking
0155  0359             //     : | |
0156  0360             //     : | |_____ sign bit (0 = signed, 1 = unsigned)
0157  0361             //     : |
0158  0362             //     : |______ 1 = space before unsigned number
0159  0363   
0160  0364   
0161  0365             func translate("arg1","arg2","arg3","arg4"), 1; // list translator (internal use only, not usable)
0162  0366   
0163  0367             func putstr("string"), 1;                       // print string to current output device
0164  0368             // Syntax: putstr(pointer);
0165  0369             // Usage : putstr("HELLO\n");
0166  0370             // Notes : putstr prints a string to the current output stream, usually the display. The argument can be
0167  0371             //     : a string constant, a pointer to a string, a pointer to an array, or a pointer to a data statement.
0168  0372             //     : The output of putstr can be redirected to the communications port, the media, or memory
0169  0373             //     : using the to(...); function.
0170  0374             //     : A string constant is automatically terminated with a zero.
0171  0375             //     : A string in a data statement is not automatically terminated with a zero.
0172  0376             //     : All variables in 4DGL are 16bit, if an array is used for holding 8 bit characters, each array
0173  0377             //     : element packs 1 or 2 characters.
0174  0378   
0175  0379   
0176  0380             func strlen("varAddress"), 1;                   // return length of a var packed string in character units
0177  0381             // Syntax: strlen("varAddress);
0178  0382             // Usage : strlen("HELLO\n");
0179  0383             // Notes : gives the length of a string that is packed into regular var array
0180  0384             //       : Use str_Length(ptr)  for string pointer mode
0181  0385   
0182  0386   
0183  0387             //==============================================//
0184  0388             // Memory Access Function Prototypes            //
0185  0389             //==============================================//
0186  0390                                                             //
0187  0391             func peekW("address"), 1;                       // read a word from system memory
0188  0392             func pokeW("address", "wordvalue"), 0;          // write a word to system memory
0189  0393             // refer to address map of internal variables   //
0190  0394             //==============================================//
0191  0395             // Math Functions                               //
0192  0396             //==============================================//
0193  0397                                                             //
0194  0398             func ABS("value"), 1;                           // return a positive number
0195  0399             // Syntax: ABS(value);
0196  0400             // Usage : var := ABS(arg);
0197  0401             // Notes : Returns the absolute value of an argument
0198  0402   
0199  0403             func MIN("value1", "value2"), 1;                // return the smaller of 2 numbers
0200  0404             // Syntax: MIN(value1, value2);
0201  0405             // Usage : var := MIN(arg1, arg2);
0202  0406             // Notes : Returns the minimum of 2 arguments
0203  0407   
0204  0408             func MAX("value1", "value2"), 1;                // return the larger of 2 numbers
0205  0409             // Syntax: MAX(value1, value2);
0206  0410             // Usage : var := MAX(arg1, arg2);
0207  0411             // Notes : Returns the maximum of 2 arguments
0208  0412   
0209  0413             func SWAP("&var", "&var"), 0;                   // swap 2 variables, arguments must point to variables
0210  0414             // Syntax: SWAP(&var1, &var2);
0211  0415             // Usage : SWAP(&var1, &var2);
0212  0416             // Notes : Swaps the contents of 2 variables or memory locations
0213  0417   
0214  0418             func SIN("angle"), 1;                           // return SIN of angle
0215  0419             // Syntax: SIN(angle);
0216  0420             // Usage : var := SIN(arg);
0217  0421             // Notes : Returns the sine in radians of an argument in degrees
0218  0422             //       : the returned value range is from 127 to -127. The real
0219  0423             //       : cosine values vary from 1.0 to -1.0 so appropriate
0220  0424             //       : scaling must be done in user code.
0221  0425   
0222  0426             func COS("angle"), 1;                           // return COS of angle
0223  0427             // Syntax: COS(angle);
0224  0428             // Usage : var := COS(arg);
0225  0429             // Notes : Returns the cosine in radians of an argument in degrees
0226  0430             //       : the returned value range is from 127 to -127. The real
0227  0431             //       : cosine values vary from 1.0 to -1.0 so appropriate
0228  0432             //       : scaling must be done in user code.
0229  0433   
0230  0434             func RAND(), 1;                                 // return a pseudo random number
0231  0435             // Syntax: RAND();
0232  0436             // Usage : var := RAND();
0233  0437             // Notes : Returns a random number between 0 and 0xFFFF.
0234  0438             //       : The random number generator must first be seeded
0235  0439             //       : by using the SEED(number) function.
0236  0440   
0237  0441             func SEED("number"), 0;                         // re-seed the pseudo random number generator
0238  0442             // Syntax: SEED(number);
0239  0443             // Usage : SEED(arg);
0240  0444             // Notes : Seeds the random number generator.
0241  0445   
0242  0446             func OVF(), 1;                                  // returns upper 16bits of 32bit results
0243  0447             // Syntax: OVF();
0244  0448             // Usage : loWord := 0x2710 * 0x2710;           // (10000 * 10000 in hex format)
0245  0449             //       : hiWord := OVF();
0246  0450             // Notes : This function returns the high order 16 bits from certain math and shift functions..
0247  0451   
0248  0452             func SQRT("number"), 1;                         // return square root of a number
0249  0453             // Syntax: SQRT(number);
0250  0454             // Usage : SQRT(arg);
0251  0455             // Notes : Returns the integer square root of a number.
0252  0456             //------------------------------------------------------------------//
0253  0457             //          Text Related Function Prototypes
0254  0458             //------------------------------------------------------------------//
0255  0459   
0256  0460             func txt_MoveCursor("line", "column"), 0;
0257  0461             // Syntax: txt_SetCursor(line, column);
0258  0462             // Usage : txt_SetCursor(arg1, arg2);
0259  0463             // Notes : Moves the text Cursor to a new screen position set by
0260  0464             //       : line,column parameters.
0261  0465   
0262  0466             func txt_Set("mode", "value"), 0;
0263  0467             // Syntax: txt_Set(mode, value);
0264  0468             // Usage : txt_Set(arg1, arg2);
0265  0469             // Returns : Original value before the change
0266  0470             // Notes : Sets various text related parameters used by other functions
0267  0471             //       : This allows the features to be set programatically with a
0268  0472             //       : single function call.It is strongly recommended to use the
0269  0473             //       : pre-defined constants rather than the mode numbers.
0270  0474             //       : NB:- Although it is often required to be able to set text
0271  0475             //       : functions with a single function call for graphics engine
0272  0476             //       : related functions, there is a complete set of single parameter
0273  0477             //       : shortcut functions that have exactly the same function as
0274  0478             //       : each of the txt_Set modes and saves 1 parameter / uses less memory
0275  0479             //       :
0276  0480             //       : mode = TEXT_COLOUR (mode 0)
0277  0481             //       : txt_Set(TEXT_COLOUR, value);
0278  0482             //       : value = 0 to 0xFFFF, Black to White
0279  0483             //       : Sets the Text colour for the display
0280  0484             //       : Default = LIME.
0281  0485             //       :
0282  0486             //       : mode = TEXT_HIGHLIGHT (mode 1)
0283  0487             //       : txt_Set(TEXT_HIGHLIGHT, value);
0284  0488             //       : value = 0 to 0xFFFF, Black to White
0285  0489             //       : Sets the Text background colour for the display. Effective
0286  0490             //       : when text mode is Opaque.
0287  0491             //       : Default = BLACK.
0288  0492             //       :
0289  0493             //       : mode = FONT_ID (mode 2)
0290  0494             //       : txt_Set(FONT_ID, value);
0291  0495             //       : value = FONT1, FONT2 or FONT3 for internal fonts
0292  0496             //       : else this value is the name of a font included
0293  0497             //       : in a users program in a data statement.
0294  0498             //       : Default = FONT SIZE 3.
0295  0499             //       :
0296  0500             //       : mode = TEXT_WIDTH  (mode 3)
0297  0501             //       : txt_Set(TEXT_WIDTH, value);
0298  0502             //       : value = 1 to 16
0299  0503             //       : Sets the Text Width multiplier
0300  0504             //       : text will be printed magnified horizontally
0301  0505             //       : by this factor, Default = 1.
0302  0506             //       :
0303  0507             //       : mode = TEXT_HEIGHT  (mode 4)
0304  0508             //       : txt_Set(TEXT_HEIGHT, value);
0305  0509             //       : value = 1 to 16
0306  0510             //       : Sets the Text Height multiplier
0307  0511             //       : text will be printed magnified vertically
0308  0512             //       : by this factor, Default = 1.
0309  0513             //       :
0310  0514             //       : mode = TEXT_XGAP  (mode 5)
0311  0515             //       : txt_Set(TEXT_XGAP, value);
0312  0516             //       : value = 1 to 32
0313  0517             //       : Sets the horizontal gap between characters
0314  0518             //       : The gap is in pixel units, Default = 0
0315  0519             //       :
0316  0520             //       : mode = TEXT_YGAP  (mode 6)
0317  0521             //       : txt_Set(TEXT_YGAP, value);
0318  0522             //       : value = 1 to 32
0319  0523             //       : Sets the vertical gap below characters
0320  0524             //       : The gap is in pixel units, Default = 0
0321  0525             //       :
0322  0526             //       : mode = TEXT_PRINTDELAY  (mode 7) DEPRECATED
0323  0527             //       : txt_Set(TEXT_PRINTDELAY, value);
0324  0528             //       : value = 0 to 255
0325  0529             //       : Sets the delay time (in ms) during character
0326  0530             //       : printing to give a 'teletype' like effect.
0327  0531             //       : Often used to attract attention to a string
0328  0532             //       : being printed which can often be missed if
0329  0533             //       : just suddenly appearing or changing.
0330  0534             //       : Default = 0 ms.
0331  0535             //       :
0332  0536             //       : mode = TEXT_OPACITY (mode 8)
0333  0537             //       : txt_Set(TEXT_OPACITY, value);
0334  0538             //       : value = TRANSPARENT (0) = Text Trasparent
0335  0539             //       : value = OPAQUE (1) = Text Opaque
0336  0540             //       : Sets the Opacity/Transparency of the text
0337  0541             //       : Default = 0 or TRANSPARENT
0338  0542             //       :
0339  0543             //       : mode = TEXT_BOLD (mode 9)
0340  0544             //       : txt_Set(TEXT_BOLD, value);
0341  0545             //       : value = dont care
0342  0546             //       : Sets Bold Text mode for the next string or char
0343  0547             //       : The feature automatically resets after printing
0344  0548             //       : using putstr or print has completed
0345  0549             //       :
0346  0550             //       : mode = TEXT_ITALIC (mode 10)
0347  0551             //       : txt_Set(TEXT_ITALIC, value);
0348  0552             //       : value = dont care
0349  0553             //       : Sets Italic Text mode for the next string or char
0350  0554             //       : The feature automatically resets after printing
0351  0555             //       : using putstr or print has completed
0352  0556   
0353  0557             //       : mode = TEXT_INVERSE (mode 11)
0354  0558             //       : txt_Set(TEXT_INVERSE, value);
0355  0559             //       : value = dont care
0356  0560             //       : Sets Inverse Text mode for the next string or char
0357  0561             //       : The feature automatically resets after printing
0358  0562             //       : using putstr or print has completed
0359  0563             //       :
0360  0564             //       : mode = TEXT_UNDERLINED (mode 12)
0361  0565             //       : txt_Set(TEXT_UNDERLINED, value);
0362  0566             //       : value = dont care
0363  0567             //       : Sets Underlined Text mode for the next string or char
0364  0568             //       : The feature automatically resets after printing
0365  0569             //       : using putstr or print has completed
0366  0570             //       :
0367  0571             //       : mode = TEXT_ATTRIBUTES (mode 13)
0368  0572             //       : txt_Set(TEXT_ATTRIBUTES, value);
0369  0573             //       : value = bits are defined as:
0370  0574             //       :  BOLD        16          // TEXT_ATTRIBUTES bold text (auto reset)
0371  0575             //       :  ITALIC      32          // TEXT_ATTRIBUTES italic text (auto reset)
0372  0576             //       :  INVERSE     64          // TEXT_ATTRIBUTES inverse text (auto reset)
0373  0577             //       :  UNDERLINED  128         // TEXT_ATTRIBUTES underlined text (auto reset)
0374  0578             //       : Allows a combination of text attributes to be defined together
0375  0579             //       : by 'or'ing the bits together.
0376  0580             //       : Example: txt_Set(TEXT_ATTRIBUTES, BOLD | INVERSE); // bold + inverse
0377  0581             //       : The feature automatically resets after printing
0378  0582             //       : using putstr or print has completed.
0379  0583             //       : Bits 0-3 and 8-15 are reserved for future attributes.
0380  0584             //       :
0381  0585             //       : mode = TEXT_WRAP (mode 14)
0382  0586             //       : txt_Set(TEXT_WRAP , value);
0383  0587             //       : Sets the position where text wrap will occur
0384  0588             //       : The feature automatically resets when screen
0385  0589             //       : mode is changed. If the value is set to 0,
0386  0590             //       : text wrap is turned off.
0387  0591             //       : of the current screen. Default value is 0
0388  0592             // Notes : The value is in pixel units.
0389  0593             //       :
0390  0594   
0391  0595             //       : txt_Set mode 15 reserved for future use
0392  0596             //       :
0393  0597   
0394  0598   
0395  0599   
0396  0600             //=====================================================//
0397  0601             // Single parameter short-cuts                         //
0398  0602             // for the txt_Set functions                           //
0399  0603             // These functions return the existing value before    //
0400  0604             // the change is made.                                 //
0401  0605             //=====================================================//
0402  0606             func txt_FGcolour("colour"), 1;             // 0  text foreground colour
0403  0607             func txt_BGcolour("colour"), 1;             // 1  text background colour
0404  0608             func txt_FontID("id"), 1;                   // 2  text font ID (0 = system font)
0405  0609             func txt_Width("multiplier"), 1;            // 3  text width multiplier
0406  0610             func txt_Height("multiplier"), 1;           // 4  text height multiplier
0407  0611             func txt_Xgap("pixelcount"), 1;             // 5  text gap between characters
0408  0612             func txt_Ygap("pixelcount"), 1;             // 6  text gap between lines
0409  0613             func txt_Delay("millisecs"), 1;             // 7  text printing delay factor
0410  0614             func txt_Opacity("mode"), 1;                // 8  text OPAQUE or TRANSPARENT
0411  0615             func txt_Bold("mode"), 1;                   // 9  text bold ON/OFF
0412  0616             func txt_Italic("mode"), 1;                 // 10 text italic ON/OFF
0413  0617             func txt_Inverse("mode"), 1;                // 11 text inverse ON/OFF
0414  0618             func txt_Underline("mode"), 1;              // 12 text underline ON/OFF
0415  0619             func txt_Attributes("value"), 1;            // 13 text combined bold|italic|inverse|underline
0416  0620             func txt_Wrap("value"), 1;                  // 14 text set text wrap position
0417  0621             func _1F(), 0;                              // 15 text (reserved DO NOT REMOVE)
0418  0622   
0419  0623   
0420  0624             //------------------------------------------------------------------//
0421  0625             //                 Hardware Function Prototypes
0422  0626             //------------------------------------------------------------------//
0423  0627   
0424  0628             // I/O Pin reference:-
0425  0629             //
0426  0630             //    IO1_PIN         is pin 2 J1
0427  0631             //    IO2_PIN         is pin 1 J1
0428  0632             //    IO3_PIN         is pin 3 J1
0429  0633             //    IO4_PIN         is pin 5 J1 (also used for BUS_RD)
0430  0634             //    IO5_PIN         is pin 9 J2 (also used for BUS_WR)
0431  0635             //    BUS_RD_PIN         is pin 5 J1 (alias IO4_PIN)
0432  0636             //    BUS_WR_PIN         is pin 9 J2 (alias IO5_PIN)
0433  0637             //    BUS_0         is pin 27 of J1
0434  0638             //    BUS_1         is pin 25 of J1
0435  0639             //    BUS_2         is pin 23 of J1
0436  0640             //    BUS_3         is pin 21 of J1
0437  0641             //    BUS_4         is pin 19 of J1
0438  0642             //    BUS_5         is pin 17 of J1
0439  0643             //    BUS_6         is pin 13 of J2
0440  0644             //    BUS_7         is pin 11 of J2
0441  0645             //    BACKLIGHT
0442  0646   
0443  0647             func pin_Set("mode", "pin"), 0;            // set pin to required mode
0444  0648             // Syntax: pin_Set(mode, pin);
0445  0649             // Usage : pin_Set(arg1, arg2);
0446  0650             // Notes : Sets the appropriate pins to Inputs or Outputs
0447  0651             //       :
0448  0652             //       : mode = 0 : Set Pin to Output
0449  0653             //       : pin_Set(0, pin);
0450  0654             //       : pin_Set(OUTPUT, pin);
0451  0655             //       : pin = 1 : set IO1_PIN to output (pin 2 J1)
0452  0656             //       : pin = 2 : set IO2_PIN to output (pin 1 J1)
0453  0657             //       : pin = 3 : set IO3_PIN to output (pin 3 J1)
0454  0658             //       : pin = 4 : set IO4_PIN to output (pin 5 J1, also used for BUS_RD)
0455  0659             //       : pin = 5 : set IO5_PIN to output (pin 9 J2, also used for BUS_WR)
0456  0660             //       : Sets the desired pin to be used as an Output.
0457  0661             //       :
0458  0662             //       : mode = 1 : Set Pin to Input
0459  0663             //       : pin_Set(1, pin);
0460  0664             //       : pin_Set(INPUT, pin);
0461  0665             //       : pin = 1 : set IO1_PIN to input (pin 2 J1)
0462  0666             //       : pin = 2 : set IO2_PIN to input (pin 1 J1)
0463  0667             //       : pin = 3 : set IO3_PIN to input (pin 3 J1)
0464  0668             //       : pin = 4 : set IO4_PIN to input (pin 5 J1, also used for BUS_RD)
0465  0669             //       : pin = 5 : set IO5_PIN to input (pin 9 J2, also used for BUS_WR)
0466  0670             //       : Sets the desired pin to be used as an Input.
0467  0671   
0468  0672             func pin_HI("pin"), 0;                    // set pin to logic '1'
0469  0673             // Syntax: pin_HI(pin);
0470  0674             // Usage : pin_HI(arg);
0471  0675             // Notes : Outputs a logic "High" (3.3V) on the appropriate
0472  0676             //       : pin that was previously selected as an Output.
0473  0677             //       :
0474  0678             //       : pin = 1 : set IO1_PIN to "High" level (pin 2 of J1)
0475  0679             //       : pin = 2 : set IO2_PIN to "High" level (pin 1 of J1)
0476  0680             //       : pin = 3 : set IO3_PIN to "High" level (pin 3 of J1)
0477  0681             //       : pin = 4 : set IO4_PIN to "High" level (pin 5 of J1, also used for BUS_RD)
0478  0682             //       : pin = 5 : set IO5_PIN to "High" level (pin 9 of J2, also used for BUS_WR)
0479  0683             //       : pin = 6 : set DCENB pin to "High" level (BACKLITE ON)
0480  0684             //       : pin = 7 : set AUDIO_ENABL pin to "High" level (AMP OFF)
0481  0685   
0482  0686             func pin_LO("pin"), 0;                    // set pin to logic '0'
0483  0687             // Syntax: pin_LO(pin);
0484  0688             // Usage : pin_LO(arg);
0485  0689             // Notes : Outputs a logic "Low" (0V) on the appropriate
0486  0690             //       : pin that was previously selected as an Output.
0487  0691             //       :
0488  0692             //       : pin = 1 : set IO1_PIN to "Low" level (pin 2 of J1)
0489  0693             //       : pin = 2 : set IO2_PIN to "Low" level (pin 1 of J1)
0490  0694             //       : pin = 3 : set IO3_PIN to "Low" level (pin 3 of J1)
0491  0695             //       : pin = 4 : set IO4_PIN to "Low" level (pin 5 of J1, also used for BUS_RD)
0492  0696             //       : pin = 5 : set IO5_PIN to "Low" level (pin 9 of J2, also used for BUS_WR)
0493  0697             //       : pin = 6 : set DCENB pin to "Low" level (BACKLITE)
0494  0698             //       : pin = 7 : set AUDIO_ENABL pin to "Low" level (AMP ON)
0495  0699   
0496  0700             func pin_Read("pin"), 1;                // read pin, logic or analogue
0497  0701             // Syntax: pin_Read(pin);
0498  0702             // Usage : arg1 := pin_Read(arg2);
0499  0703             // Notes : Reads the logic state of the appropriate
0500  0704             //       : pin that was previously selected as an Input.
0501  0705             //       :
0502  0706             //       : pin = 1 : Read the state of IO1_PIN (pin 2 of J1)
0503  0707             //       : pin = 2 : Read the state of IO2_PIN (pin 1 of J1)
0504  0708             //       : pin = 3 : Read the state of IO3_PIN (pin 3 of J1)
0505  0709             //       : pin = 4 : Read the state of IO4_PIN (pin 5 of J1, also used for BUS_RD)
0506  0710             //       : pin = 5 : Read the state of IO5_PIN (pin 9 of J2, also used for BUS_WR)
0507  0711             //       : Returns a 0 (logic low) or 1 (logic high).
0508  0712   
0509  0713   
0510  0714             //------------------------------------------------------------------//
0511  0715             //                 P1 module BUS I/O control
0512  0716             //------------------------------------------------------------------//
0513  0717   
0514  0718             func bus_In(), 1;
0515  0719             // Syntax: bus_In();
0516  0720             // Usage : arg1 := bus_In();
0517  0721             // Notes : Read the 8bit wide bus into the lower 8 bits of arg1.
0518  0722             //       : The upper 8 bits of arg1 are set to 0.
0519  0723             //       : the BUS_RD and BUS_WR pins are not affected.
0520  0724             //       :
0521  0725             //       : BUS_0 is pin 27 of J1
0522  0726             //       : BUS_1 is pin 25 of J1
0523  0727             //       : BUS_2 is pin 23 of J1
0524  0728             //       : BUS_3 is pin 21 of J1
0525  0729             //       : BUS_4 is pin 19 of J1
0526  0730             //       : BUS_5 is pin 17 of J1
0527  0731             //       : BUS_6 is pin 13 of J2
0528  0732             //       : BUS_7 is pin 11 of J2
0529  0733   
0530  0734             func bus_Out("var"), 0;
0531  0735             // Syntax: bus_Out(var);
0532  0736             // Usage : bus_Out(arg1);
0533  0737             // Notes : The lower 8 bits of arg1 are placed on the 8bit wide bus.
0534  0738             //       : The upper 8 bits of arg1 are ignored.
0535  0739             //       : the BUS_RD and BUS_WR pins are not affected.
0536  0740             //       : NB:- any BUS pins that are set to inputs are not affected.
0537  0741             //       :
0538  0742             //       : BUS_0 is pin 27 of J1
0539  0743             //       : BUS_1 is pin 25 of J1
0540  0744             //       : BUS_2 is pin 23 of J1
0541  0745             //       : BUS_3 is pin 21 of J1
0542  0746             //       : BUS_4 is pin 19 of J1
0543  0747             //       : BUS_5 is pin 17 of J1
0544  0748             //       : BUS_6 is pin 13 of J2
0545  0749             //       : BUS_7 is pin 11 of J2
0546  0750   
0547  0751             func bus_Set("var"), 0;
0548  0752             // Syntax: bus_Set(var);
0549  0753             // Usage : bus_Set(arg1);
0550  0754             // Notes : The lower 8 bits of arg1 are placed in the BUS direction register.
0551  0755             //       : a '1' sets a pin to be an input, a '0' sets a pin to be output.
0552  0756             //       : The upper 8 bits of arg1 are ignored.
0553  0757             //       : the BUS_RD and BUS_WR pins are not affected.
0554  0758             //       :
0555  0759             //       : BUS_0 is pin 27 of J1
0556  0760             //       : BUS_1 is pin 25 of J1
0557  0761             //       : BUS_2 is pin 23 of J1
0558  0762             //       : BUS_3 is pin 21 of J1
0559  0763             //       : BUS_4 is pin 19 of J1
0560  0764             //       : BUS_5 is pin 17 of J1
0561  0765             //       : BUS_6 is pin 13 of J2
0562  0766             //       : BUS_7 is pin 11 of J2
0563  0767   
0564  0768             func bus_Write("var"), 0;
0565  0769             // Syntax: bus_Write(var);
0566  0770             // Usage : bus_Write(arg1);
0567  0771             // Notes : The lower 8 bits of arg1 are placed on the BUS, then, after
0568  0772             //       : a settling delay of approx 50nsec, the BUS_WR pin is strobed
0569  0773             //       : LO for approx 50nsec then set back HI.
0570  0774             //       : The upper 8 bits of arg1 are ignored.
0571  0775             //       : NB:- the BUS_WR pin is automatically pre-set to an output to
0572  0776             //       : ensure BUS write integrity.
0573  0777             //       :
0574  0778             //       : BUS_0 is pin 27 of J1
0575  0779             //       : BUS_1 is pin 25 of J1
0576  0780             //       : BUS_2 is pin 23 of J1
0577  0781             //       : BUS_3 is pin 21 of J1
0578  0782             //       : BUS_4 is pin 19 of J1
0579  0783             //       : BUS_5 is pin 17 of J1
0580  0784             //       : BUS_6 is pin 13 of J2
0581  0785             //       : BUS_7 is pin 11 of J2
0582  0786   
0583  0787             func bus_Read(), 1;
0584  0788             // Syntax: bus_Read();
0585  0789             // Usage : arg1 := bus_Read();
0586  0790             // Notes : The BUS_RD pin set to LO, then, after a settling delay
0587  0791             //       : of approx 50nsec, the BUS is read into the lower 8 bits of arg
0588  0792             //       : (the upper 8 bits being set to 0)
0589  0793             //       : the BUS_RD pin is then set back to a HI level.
0590  0794             //       : NB:- the BUS_RD pin is automatically pre-set to an output to
0591  0795             //       : ensure BUS write integrity.
0592  0796             //       :
0593  0797             //       : BUS_0 is pin 27 of J1
0594  0798             //       : BUS_1 is pin 25 of J1
0595  0799             //       : BUS_2 is pin 23 of J1
0596  0800             //       : BUS_3 is pin 21 of J1
0597  0801             //       : BUS_4 is pin 19 of J1
0598  0802             //       : BUS_5 is pin 17 of J1
0599  0803             //       : BUS_6 is pin 13 of J2
0600  0804             //       : BUS_7 is pin 11 of J2
0601  0805   
0602  0806   
0603  0807             //------------------------------------------------------------------//
0604  0808             //   Graphics Functions
0605  0809             //------------------------------------------------------------------//
0606  0810             func gfx_Set("mode", "value"), 0;            // set various graphics functions
0607  0811             // Syntax: gfx_Set(mode, value);
0608  0812             // Usage : gfx_Set(arg1, arg2);
0609  0813             // Notes : Sets various graphics parameters used by other functions
0610  0814             //       : This allows the features to be set programatically with a
0611  0815             //       : single function call.It is strongly recommended to use the
0612  0816             //       : pre-defined constants rather than the mode numbers.
0613  0817             //       : NB:- Although it is often required to be able to set graphics
0614  0818             //       : functions with a single function call for graphics engine
0615  0819             //       : related functions, there is a complete set of single parameter
0616  0820             //       : shortcut functions that have exactly the same function as
0617  0821             //       : each of the gfx_Set modes and saves 1 parameter / uses less memory
0618  0822             //       :
0619  0823             //       : mode = PEN_SIZE (mode 16)
0620  0824             //       : gfx_Set(PEN_SIZE, value);
0621  0825             //       : value = SOLID (value 0) rectangle and circle objects are solid
0622  0826             //       : value = OUTLINE (value 1) rectangle and circle objects are outlines
0623  0827             //       : Sets the mode of the Pen used by most graphics objects
0624  0828             //       :
0625  0829             //       : mode = BACKGROUND_COLOUR (mode 17)
0626  0830             //       : gfx_Set(BACKGROUND_COLOUR, value);
0627  0831             //       : value = 0 to 0xFFFF, Black to White
0628  0832             //       : Sets the Background colour of the screen
0629  0833             //       :
0630  0834             //       : mode = OBJECT_COLOUR (mode 18)
0631  0835             //       : gfx_Set(OBJECT_COLOUR, value);
0632  0836             //       : value = 0 to 0xFFFF, Black to White
0633  0837             //       : Sets the Object colour used in various functions
0634  0838             //       : LineTo(,,); LineRel(,,); BoxTo(,,); Dot(); etc.
0635  0839             //       :
0636  0840             //       : mode = CLIPPING (mode 19)
0637  0841             //       : gfx_Set(CLIPPING, value);
0638  0842             //       : value = OFF (value 0) Clipping disabled
0639  0843             //       : value = ON (value 1) Clipping enabled
0640  0844             //       : Enables/Disables the Clipping feature
0641  0845             //       :
0642  0846             //       : mode = TRANSPARENT_COLOUR (mode 20) : Image or Animation Transparency Colour.
0643  0847             //       : gfx_Set(TRANSPARENT_COLOUR, value);
0644  0848             //       : value = 0 to 0xFFFF Black to White
0645  0849             //       : Sets Bitmap, Image or Animation Transparency Colour.
0646  0850             //       : NB not implemented
0647  0851             //       :
0648  0852             //       : mode = TRANSPARENCY (mode 21) : Bitmap/Image/Animation Transparency
0649  0853             //       : gfx_Set(5, value);
0650  0854             //       : value = OFF (value 0) Transparency disabled
0651  0855             //       : value = ON (value 1) Transparency enabled
0652  0856             //       : Enables/Disables the Transparency feature
0653  0857             //       : NB not implemented
0654  0858             //       :
0655  0859             //       : mode = FRAME_DELAY (mode 22) : Inter-Frame Delay
0656  0860             //       : gfx_Set(FRAME_DELAY, value);
0657  0861             //       : value = 0 to 65535 ms
0658  0862             //       : Sets the Video/Animation clip inter-frame delay. This setting will
0659  0863             //       : over-ride the embedded frame delay of the clip. After the event,
0660  0864             //       : the setting will auto disable and if further inter-frame delays need
0661  0865             //       : overriding the setting must be re-issued.
0662  0866             //       :
0663  0867             //       : mode = SCREEN_MODE (mode 23) : Set required screen behaviour
0664  0868             //       : gfx_Set(SCREEN_MODE, value);
0665  0869             //       : value = LANDSCAPE   (value 0)
0666  0870             //       : value = LANDSCAPE_R (value 1)
0667  0871             //       : value = PORTRAIT    (value 2)
0668  0872             //       : value = PORTRAIT_R  (value 3)
0669  0873             //       :
0670  0874             //       : mode = OUTLINE_COLOUR (mode 24) : Outline Colour
0671  0875             //       : gfx_Set(OUTLINE_COLOUR, value);
0672  0876             //       : value = 1 to 0xFFFF, if 0, featre is OFF
0673  0877             //       : Sets the filled Rectangle or Circle objects outline colour
0674  0878             //       : If outline colour, is 0, OUTLINE_COLOUR feature is disabled
0675  0879             //       : gfx_Set(OUTLINE_COLOUR, OFF); may be used for this
0676  0880             //       :
0677  0881             //       : Only supports variable contrast for uOLED Modules
0678  0882             //       : mode = CONTRAST (mode 25) : Contrast
0679  0883             //       : gfx_Set(CONTRAST, value);
0680  0884             //       : value = 0 to 9, 0=off, 1=lowest, 8=highest contrast
0681  0885             //       : when contrast=0, display is placed in low power mode.
0682  0886             //       : This function should be called with contrast=0 when
0683  0887             //       : powering down the module.
0684  0888             //       :
0685  0889             //       : mode = LINE_PATTERN (mode 26) : Line Pattern
0686  0890             //       : gfx_Set(LINE_PATTERN, value);
0687  0891             //       : gfx_Set(LINE_PATTERN, 0b1111000011110000); // draw dotted line
0688  0892             //       : gfx_Set(LINE_PATTERN, OFF); // line patterning OFF
0689  0893             //       : a value of 0 turns the feature off
0690  0894             //       :
0691  0895             //       : mode = COLOUR_MODE (mode 27) : 8/16 bit colour mode
0692  0896             //       : gfx_Set(COLOUR_MODE , COLOUR16);   // set 16bit colour mode
0693  0897             //       : gfx_Set(COLOUR_MODE , COLOUR8);   // set 8bit colour mode
0694  0898             //       : NB not implemented, default is COLOUR16
0695  0899             //       :
0696  0900             //       : mode = BEVEL_WIDTH (mode 28) : set button and slider bevel width
0697  0901             //       : gfx_Set(BEVEL_WIDTH , 5);   // set bevel lines to 5 pixels wide
0698  0902             //       : sets the button and slider objects bevel width
0699  0903             //       :
0700  0904             //       : mode = BEVEL_SHADOW (mode 29) : set bevel shadowing depth for buttons and sliders
0701  0905             //       : gfx_Set(BEVEL_SHADOW , 5);
0702  0906             //       : sets the button and slider objects darken and lighten depth for the bevel colour
0703  0907             //       :
0704  0908             //       : mode = X_ORIGIN (mode 29) : set x offset for screen
0705  0909             //       : gfx_Set(X_ORIGIN , 25);  // object are offset 25 pixels from LHS
0706  0910             //       : sets the origin of drawn objects to a position other than 0,0
0707  0911             //       :
0708  0912             //       : mode = Y_ORIGIN (mode 29) : set y offset for screen
0709  0913             //       : gfx_Set(Y_ORIGIN , 30);  // object are offset 30 pixels from TOP
0710  0914             //       : sets the origin of drawn objects to a position other than 0,0
0711  0915   
0712  0916   
0713  0917             func gfx_Cls(), 0;                    // clear the screen
0714  0918             // Syntax: gfx_Cls();
0715  0919             // Usage : gfx_Cls();
0716  0920             // Notes : Clears the screen with current background colour
0717  0921   
0718  0922             func gfx_MoveTo("x", "y"), 0;                // set glb_X1 and glb_Y1 to required co-ordinate
0719  0923             // Syntax: gfx_MoveTo(x, y);
0720  0924             // Usage : gfx_MoveTo(arg1, arg2);
0721  0925             // Notes : Moves the origin to a new x,y position
0722  0926   
0723  0927             func gfx_MoveRel("x", "y"), 0;                // set glb_X1 and glb_Y1 to new relative offset
0724  0928             // Syntax: gfx_MoveRel(x, y);
0725  0929             // Usage : gfx_MoveRel(arg1, arg2);
0726  0930             // Notes : Moves the origin to a new x,y position
0727  0931             //       : relative to the current origing
0728  0932   
0729  0933             func gfx_LineTo("x1", "y1"), 0;                     // draw line from current origin to new point
0730  0934             // Syntax: gfx_LineTo(x1, y1);
0731  0935             // Usage : gfx_LineTo(arg1, arg2);
0732  0936             // Notes : Draws a Line from the origin x,y to x1,y1.
0733  0937             //       : The new origin is then set to x1, y1. Line colour needs
0734  0938             //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
0735  0939   
0736  0940             func gfx_LineRel("x1", "y1"), 0;                    // draw line from current origin to new relative offset
0737  0941             // Syntax: gfx_LineRel(x1, y1);
0738  0942             // Usage : gfx_LineRel(arg1, arg2);
0739  0943             // Notes : Draws a Line from the origin x,y to x1,y1.
0740  0944             //       : Unlike gfx_MoveTo() the origin is not updated with x1, y1. Line colour needs
0741  0945             //       : to be preset with "Set Object colour" using gfx_Set(OBJECT_COLOUR, colour);
0742  0946   
0743  0947             func gfx_Line("x1", "y1", "x2", "y2", "colr"), 0;   // draw line, can be patterned
0744  0948             // Syntax: gfx_Line(x1, x2, y2, colr);
0745  0949             // Usage : gfx_Line(arg1, arg2, arg3, arg4, arg5);
0746  0950             // Notes : Plots a coloured Line from x1,y1 to x2,y2 on the screen
0747  0951   
0748  0952             func gfx_Hline("y", "x1", "x2", "colr"), 1;         // draw Hline, can be patterned
0749  0953             // Syntax: gfx_Line(x1, x2, y, colr);
0750  0954             // Usage : gfx_Line(arg1, arg2, arg3, arg4);
0751  0955             // Notes : Plots a coloured Horizontal line from x1,y to x2,y on the screen
0752  0956   
0753  0957             func gfx_Vline("x", "y1", "y2", "colr"), 1;         // draw Vline, can be patterned
0754  0958             // Syntax: gfx_Line(y1, y2, x, colr);
0755  0959             // Usage : gfx_Line(arg1, arg2, arg3, arg4);
0756  0960             // Notes : Plots a coloured Vertical line from x,y1 to x,y2 on the screen
0757  0961   
0758  0962             func gfx_Rectangle("x1" ,"y1", "x2", "y2", "colr"), 0;    // draw open rectangle,line can be patterned
0759  0963             // Syntax: gfx_Rectangle(x1, y1, x2, y2, colr);
0760  0964             // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
0761  0965             // Notes : Plots a coloured Outline Rectangle from top corner (x1,y1) to
0762  0966             //       : bottom corner (x2,y2) on the screen.
0763  0967   
0764  0968             func gfx_RectangleFilled("x1","y1","x2","y2","colr"), 0;    // draw filled rectangle
0765  0969             // Syntax: gfx_Rectangle(x1, y1, x2, y2, colour);
0766  0970             // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
0767  0971             // Notes : Plots a coloured Solid Rectangle from top corner (x1,y1) to
0768  0972             //       : bottom corner (x2,y2) on the screen.
0769  0973   
0770  0974             func gfx_Circle("x", "y", "rad", "colr"), 0;        // draw open circle
0771  0975             // Syntax: gfx_Circle(x, y, rad, colr);
0772  0976             // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
0773  0977             // Notes : Plots a coloured outline Circle on the screen at centre x,y with radius = rad
0774  0978   
0775  0979             func gfx_CircleFilled("x", "y", "rad", "colr"), 0;    // draw filled circle
0776  0980             // Syntax: gfx_Circle(x, y, rad, colr);
0777  0981             // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
0778  0982             // Notes : Plots a coloured Solid Circle on the screen at centre x,y with radius = rad
0779  0983   
0780  0984             func gfx_PutPixel("x", "y", "colr"), 0;            // set point at x y
0781  0985             // Syntax: gfx_PutPixel(x, y, colr);
0782  0986             // Usage : gfx_PutPixel(arg1, arg2, arg3);
0783  0987             // Notes : Plots a coloured pixel on the screen at x,y location
0784  0988   
0785  0989             func gfx_GetPixel("x", "y"), 1;                // read colour at point x y
0786  0990             // Syntax: gfx_GetPixel(x, y);
0787  0991             // Usage : var := gfx_GetPixel(arg1, arg2);
0788  0992             // Notes : Reads and returns the colour value of a pixel at location x,y
0789  0993   
0790  0994             func gfx_Triangle("x1","y1","x2","y2","x3","y3","colr"), 0; // draw an open triangle
0791  0995             // Syntax: gfx_Triangle(x1, y1, x2, y2, x3, y3, colr);
0792  0996             // Usage : gfx_Triangle(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
0793  0997             // Notes : Plots a coloured outline Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
0794  0998             //       : Vertices must be specified in an anti-clockwise fashion
0795  0999   
0796  1000             func gfx_OrbitInit("&x_orb", "&y_orb"), 0;        // set result holders for orbit command
0797  1001             // Syntax: gfx_OrbitInit(&x_orb, &y_orb);
0798  1002             // Usage : gfx_OrbitInit(&arg1, &arg2);
0799  1003             // Notes : Sets up the Orbit function parameters.
0800  1004             //       : &x_orb, &y_orb: calcualted Orbit coordiantes. These are pointers to local
0801  1005             //       : variables that get updated after calling gfx_Orbit(,,) function.
0802  1006             //       : The coordiantaes are calculated relative to the origin
0803  1007             //       : obtained by using the gfx_MoveTo(x, y) function.
0804  1008   
0805  1009             func gfx_Orbit("angle", "distance"), 0;            // calculate point at angle, distance
0806  1010             // Syntax: gfx_Orbit(angle, distance);
0807  1011             // Usage : gfx_Orbit(arg1, arg2);
0808  1012             // Notes : The Orbit function calcualtes the x, y coordinates of a distant point whose
0809  1013             //       : only known parameters are the angle and the distance from the current origin.
0810  1014   
0811  1015             func gfx_Polyline("n", "&vx", "&vy", "colr"), 0;    // draw a polyline from a table of vertices
0812  1016             // Syntax: gfx_Polyline(numbVertices, &vertices_x, &vertices_y, colour);
0813  1017             // Usage : gfx_Polyline(arg1, x[array], y[array], arg2);
0814  1018             // Notes : This function is very similar to the Ploygon function
0815  1019             //       : with the exception of the 1st and the last vertices not joined.
0816  1020   
0817  1021             func gfx_Polygon("n", "&vx", "&vy", "colr"), 0;        // draw a polygon from a table of vertices
0818  1022             // Syntax: gfx_Polygon(numbVertices, &vx, &y, colour);
0819  1023             // Usage : gfx_Polygon(arg1, x[array], y[array], arg2);
0820  1024             // Notes : Plots a coloured outline Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
0821  1025             //       : Vertices must be minimum of 3 and can be specified in any fashion
0822  1026   
0823  1027             func gfx_Dot(), 0;                    // set point at glb_X glb_Y, default colour
0824  1028             // Syntax: gfx_Dot();
0825  1029             // Usage : gfx_Dot();
0826  1030             // Notes : Places a coloured dot at the origin
0827  1031   
0828  1032   
0829  1033             func gfx_Bullet("r"), 0;                // draw circle at glb_X glb_Y, default colour
0830  1034             // Syntax: gfx_Dot();
0831  1035             // Usage : gfx_Dot();
0832  1036             // Notes : Places a coloured dot at the origin
0833  1037   
0834  1038             func gfx_IncX(), 1;                    // increment global origin glb_X, returning new value
0835  1039             // Syntax: gfx_IncX();
0836  1040             // Usage : var := gfx_IncX();
0837  1041             // Notes : Increments the x coordinate of the origin
0838  1042   
0839  1043             func gfx_IncY(), 1;                    // increment global origin glb_Y, returning new value
0840  1044             // Syntax: gfx_IncY();
0841  1045             // Usage : var := gfx_IncY();
0842  1046             // Notes : Increments the y coordinate of the origin
0843  1047   
0844  1048             func gfx_BoxTo("x1", "y1"), 0;                // draw rectangle from current origin to x1 y1
0845  1049             // Syntax: gfx_BoxTo(x1, y1);
0846  1050             // Usage : gfx_BoxTo(arg1, arg2);
0847  1051             // Notes : Draws a Rectangle from the origin x,y to x1,y1.
0848  1052             //       : The new origin is then set to x1,y1. Rectangle colour needs
0849  1053             //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
0850  1054             //       : and the PenSize setting determines if Box is solid or outline.
0851  1055   
0852  1056             func gfx_ClipWindow("x1" ,"y1", "x2", "y2"), 0;         // set the cipping area
0853  1057             // Syntax: gfx_ClipWindow(x1, y1, x2, y2);
0854  1058             // Usage : gfx_ClipWindow(arg1, arg2, arg3, arg4);
0855  1059             // Notes : Specifies a clipping window region on the screen such that any objects
0856  1060             //       : and text placed onto the screen will be clipped and displayed only
0857  1061             //       : within that region. For the clipping window to take effect, "Clipping"
0858  1062             //       : must be enabled seperately using the gfx_Set(CLIPPING, ON) command.
0859  1063   
0860  1064   
0861  1065             func gfx_ChangeColour("oldcolr", "newcolr"), 0;         // change pixel colour in clipping area
0862  1066             // Syntax: gfx_ChangeColour(oldcolr, newcolr);
0863  1067             // Usage : gfx_ChangeColour(0xFF00, 0XFFFF);
0864  1068             // *Notes:
0865  1069   
0866  1070             func gfx_SetClipRegion(), 0;                            // set clipping area to the most recent extents
0867  1071             // Syntax: gfx_SetClipRegion();
0868  1072             // Usage : var := gfx_SetClipRegion();
0869  1073             // *Notes:
0870  1074   
0871  1075             func gfx_Ellipse("x", "y", "xrad", "yrad", "colour"), 0;
0872  1076             // Syntax: gfx_Ellipse(x, y, xrad, yrad, colour);
0873  1077             // Usage : gfx_Ellipse(arg1, arg2, arg3, arg4, arg5);
0874  1078             // Notes : Plots a coloured Ellipse on the screen at centre x,y
0875  1079             //       : with xradius = xrad and yradius = yrad.
0876  1080             //       : if PenSize = 0 Ellipse is Solid
0877  1081             //       : if PenSize = 1 Ellipse is Outline
0878  1082   
0879  1083   
0880  1084             func gfx_EllipseFilled("x", "y", "xrad", "yrad", "colour"), 0;
0881  1085             // Syntax: gfx_Ellipse(x, y, xrad, yrad, colour);
0882  1086             // Usage : gfx_Ellipse(arg1, arg2, arg3, arg4, arg5);
0883  1087             // Notes : Plots a coloured Ellipse on the screen at centre x,y
0884  1088             //       : with xradius = xrad and yradius = yrad.
0885  1089   
0886  1090             func gfx_Button("state", "x", "y", "buttonColour", "textColour", "font", "textWidth", "textHeight", "text"), 0;
0887  1091             // Syntax: gfx_Button(mode, x, y, buttonColour, textColour, font, textWidth, textHeight, text);
0888  1092             // Usage : gfx_Button(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
0889  1093             // Notes : Draws a 3 dimensional Text Button at screen location defined by
0890  1094             //       : x,y arguments (top left corner). The size of the button depends on
0891  1095             //       : the font, width, height and length of the text.
0892  1096             //       : The button appearance will depend on the state parameter setting:
0893  1097             //       :         state = 0 : Button Pressed
0894  1098             //       :         state = 1 : Button Raised
0895  1099   
0896  1100             func gfx_Panel("state", "x", "y", "width", "height", "colour"), 0;
0897  1101             // Syntax: gfx_Panel("style", "x", "y", "width", "height", "colour"), 0;
0898  1102             // Usage : gfx_Panel(PANEL_RAISED, x, y, w, h, GRAY);
0899  1103             // Notes : Draws a panel (groupbox) at screen location defined by
0900  1104             //       : x, y, width and height with colour "colour".
0901  1105             //       :         state = 0 : recessed
0902  1106             //       :         state = 1 : raised
0903  1107   
0904  1108             func gfx_Slider("mode", "x1", "y1", "x2", "y2", "colour", "scale", "value"), 1;
0905  1109             // Syntax: gfx_Slider(mode, x1, y1, x2, y2, colour, scale, value);
0906  1110             // Usage : gfx_Slider(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
0907  1111             // Notes : Draws a 3 dimensional Slider Bar on the screen.
0908  1112             //       : Slider parameters are as follows:
0909  1113             //       :         mode = 0 : Slider recessed
0910  1114             //       :         mode = 1 : Slider raised
0911  1115             //       :         x1, y1 = top left corner
0912  1116             //       :         x2, y2 = bottom right corner
0913  1117             //       :         scale = n : sets the full scale range from 0 to n
0914  1118             //       :         value = m : sets the relative position of the thumb 0 <= m <= n
0915  1119             //       : returns:-
0916  1120   
0917  1121   
0918  1122             func gfx_ScreenCopyPaste("xs", "ys", "xd", "yd", "width", "height"), 0;
0919  1123             // Syntax: gfx_ScreenCopyPaste(xs, ys, xd, yd, width, height);
0920  1124             // Usage : gfx_ScreenCopyPaste(arg1, arg2, arg3, arg4, arg5, arg6);
0921  1125             // Notes : Copies an area of a screen from xs,ys of size given by width and height
0922  1126             //       : and pastes it to another location determined by xd, yd.
0923  1127   
0924  1128             func gfx_RGBto565("RED", "GREEN", "BLUE"), 1;
0925  1129             // Syntax: gfx_RGBto565(red, green, blue);
0926  1130             // Usage : gfx_RGBto565(arg1, arg2, arg3);
0927  1131             // Notes : Returns the 16bit (565 format) colour value of a 24bit (R,G,B format) colour
0928  1132   
0929  1133             func gfx_332to565("COLOUR8BIT"), 1;
0930  1134             // Syntax: gfx_332to565(colour);
0931  1135             // Usage : gfx_332to565(arg);
0932  1136             // Notes : Returns the 16bit (565 format) colour value of an 8 bit (332 format) colour
0933  1137   
0934  1138             func gfx_Selection("index", "backcolor", "textcolor"), 0;
0935  1139             // Syntax: gfx_Selection("index", "backcolor", "textcolor"), 0;
0936  1140             // Usage : gfx_Selection(1, RED, YELLOW);
0937  1141             // Notes : Called prior to drawing a button, this function
0938  1142             //       : hilites the required text line on a multiline button.
0939  1143   
0940  1144             func gfx_TriangleFilled("x1","y1","x2","y2","x3","y3","colr"), 0; // draw a filled triangle
0941  1145             // Syntax: gfx_TriangleFilled(x1, y1, x2, y2, x3, y3, colr);
0942  1146             // Usage : gfx_TriangleFilled(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
0943  1147             // Notes : Plots a coloured Solid Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
0944  1148             //       : Vertices must be specified in an anti-clockwise fashion
0945  1149   
0946  1150   
0947  1151             func gfx_PolygonFilled("n", "&vx", "&vy", "colr"), 0;        // draw a filled polygon from a table of vertices
0948  1152             // Syntax: gfx_PolygonFilled(numbVertices, &vx, &y, colour);
0949  1153             // Usage : gfx_PolygonFilled(arg1, x[array], y[array], arg2);
0950  1154             // Notes : Plots a solid Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
0951  1155             //       : Vertices must be minimum of 3 and can be specified in any fashion
0952  1156   
0953  1157   
0954  1158             func gfx_Origin("x", "y"), 0;            // set relative screen offset for graphics objects
0955  1159             // Syntax: gfx_Offset(x, y);
0956  1160             // Usage : gfx_Offset(arg1, arg2);
0957  1161             // Notes : Set the screen offset
0958  1162   
0959  1163   
0960  1164   
0961  1165             func gfx_Get("mode"), 1;
0962  1166             // Syntax: gfx_Get(mode);
0963  1167             // Usage : arg1 := gfx_Get(arg);
0964  1168             // Notes : Returns various parameters to caller
0965  1169             //       :
0966  1170             //       : mode = X_MAX (mode 0) : current orientations maximum X value
0967  1171             //       : var := gfx_Get(X_MAX);
0968  1172             //       : Returns the maximum horizontal value of the display
0969  1173             //       :
0970  1174             //       : mode = Y_MAX (mode 1) : Vcurrent orientations maximum Y value
0971  1175             //       : var := gfx_Get(Y_MAX);
0972  1176             //       : Returns the maximum vertical value of the display
0973  1177             //       :
0974  1178             //       : mode = LEFT_POS (mode 2) : Left location of last Object
0975  1179             //       : var := gfx_Get(LEFT_POS);
0976  1180             //       : Returns the left location of the last drawn object
0977  1181             //       : such as a slider or button or an image/video
0978  1182             //       :
0979  1183             //       : mode = TOP_POS (mode 3) : Top location of Object
0980  1184             //       : var := gfx_Get(TOP_POS);
0981  1185             //       : Returns the top location of the last drawn object
0982  1186             //       : such as a slider or button or an image/video
0983  1187             //       :
0984  1188             //       : mode = RIGHT_POS (mode 4) : Right location of last Object
0985  1189             //       : var := gfx_Get(RIGHT_POS);
0986  1190             //       : Returns the right location of the last drawn object
0987  1191             //       : such as a slider or button or an image/video
0988  1192             //       :
0989  1193             //       : mode = BOTTOM_POS  (mode 5) : Bottom location of Object
0990  1194             //       : var := gfx_Get(BOTTOM_POS );
0991  1195             //       : Returns the bottom location of the last drawn object
0992  1196             //       : such as a slider or button or an image/video
0993  1197             //       :
0994  1198   
0995  1199   
0996  1200             //==================================================//
0997  1201             // Single parameter short-cuts                      //
0998  1202             // for the gfx_Set functions                        //
0999  1203             // These functions return the existing value before //
1000  1204             // the change is made.                              //
1001  1205             //==================================================//
1002  1206             func gfx_PenSize("mode"), 1;                        // 0  graphics pen size, SOLD or OUTLINE
1003  1207             func gfx_BGcolour("colour"), 1;                     // 1  graphics background colour
1004  1208             func gfx_ObjectColour("colour"), 1;                 // 2  graphics object colour
1005  1209             func gfx_Clipping("mode"), 0;                       // 3  graphics clipping ON/OFF
1006  1210             func gfx_TranparentColour("colour"), 1;             // 4  graphics image transparent mask colour
1007  1211             func gfx_Tranparency("mode"), 1;                    // 5  graphics image transparent mode ON/OFF
1008  1212             func gfx_FrameDelay("milliseconds"), 1;             // 6  graphics animation frame delay
1009  1213             func gfx_ScreenMode("mode"), 1;                     // 7  graphics orientation LANDSCAPE, LANDSCAPE_R, PORTRAIT, PORTRAIT_R
1010  1214             func gfx_OutlineColour("colour"), 1;                // 8  graphics rectangle/circle outline colour
1011  1215             func gfx_Contrast("value"), 1;                      // 9  graphics hardware value 0 to 9, 0=off, 1=lowest, 8=highest (only for AMOLED devices)
1012  1216             func gfx_LinePattern("value"), 1;                   // 10 graphics line draw tesselation pattern (16 linear bits, 1=pixel off)
1013  1217             func gfx_ColourMode("mode"), 1;                     // 11 graphics colour mode COLOUR8 or COLOUR16 (default colour 16)
1014  1218             func gfx_BevelWidth("mode"), 1;                     // 12 graphics button bevel width
1015  1219             func gfx_BevelShadow("value"), 1;                   // 13 graphics button bevel shadow depth
1016  1220             func gfx_Xorigin("offset"), 1;                      // 14 graphics  X origin
1017  1221             func gfx_Yorigin("offset"), 1;                      // 15 graphics  Y origin
1018  1222   
1019  1223   
1020  1224             //==================================================//
1021  1225             // uSD/FLASH Function Prototypes                    //
1022  1226             //==================================================//
1023  1227             func media_Video("x", "y"), 0;                      // display movie at position x y
1024  1228             // Syntax: media_Video(x, y);
1025  1229             // Usage : media_Video(arg1, arg2);
1026  1230             // Notes : Play a Video/Animation clip from the uSD card at screen location
1027  1231             //       : specified by x,y (top left corner). The location of the clip in the
1028  1232             //       : uSD card must be specified by media_setSector(Video_Sector_Add) function.
1029  1233   
1030  1234             func media_VideoFrame("x", "y","framenumber"), 0;   // display required frame from a movie at x y
1031  1235             // Syntax: media_VideoFrame(Frame_number);
1032  1236             // Usage : arg1 := media_VideoFrame();
1033  1237             // Notes : After a pointer to a valid video has been set with media_SetSector,
1034  1238             //       : calling this function shows each fram sequentially, returning
1035  1239             //       : the number of frames remaining. The position of the image is
1036  1240             //     : at the current origin as set with gfx_MoveTo(...);
1037  1241   
1038  1242             func media_SetAdd("HiWord", "LoWord"), 0;           // set stream byte address
1039  1243             // Syntax: media_SetAdd(AddHiWord, AddLoWord);
1040  1244             // Usage : media_SetAdd(arg1, arg2);
1041  1245             // Notes : Set uSD internal Address pointer for bytewise access
1042  1246   
1043  1247             func media_SetSector("HiWord", "LoWord"), 0;        // set stream sector address
1044  1248             // Syntax: media_SetSector(SectHiWord, SectLoWord);
1045  1249             // Usage : media_SetSector(arg1, arg2);
1046  1250             // Notes : Set uSD internal Sector pointer for sector block access
1047  1251   
1048  1252             func media_RdSector("*destination"), 1;
1049  1253             // Syntax: media_RdSector(*destination);
1050  1254             // Usage : media_RdSector(rdblock);
1051  1255             // Notes : Reads and Returns 512 bytes (256 words) into a destination
1052  1256             //       : block (eg rdblock[256]) pointed to by the internal Sector pointer.
1053  1257             //       : After the read the Sector pointer is automatically incremented by 1.
1054  1258             //       : Returns TRUE if uSD response was TRUE
1055  1259   
1056  1260             func media_WrSector("*source"), 1;
1057  1261             // Syntax: media_WrSector(*source);
1058  1262             // Usage : media_WrSector(wrblock);
1059  1263             // Notes : Writes 512 bytes (256 words) from a source memory block
1060  1264             //       : (eg wrblock[256]) into the uSD card. After the write the Sector
1061  1265             //       : pointer is automatically incremented by 1.
1062  1266             //       : Returns TRUE if uSD response was TRUE
1063  1267   
1064  1268             func media_ReadByte(), 1;                // read a byte at the current stream position
1065  1269             // Syntax: media_RdByte();
1066  1270             // Usage : var := media_RdByte();
1067  1271             // Notes : Reads and Returns a single byte of data from the
1068  1272             //       : uSD card pointed to by the internal Address pointer.
1069  1273             //       : After the read the Address pointer is automatically
1070  1274             //       : incremented by 1.
1071  1275   
1072  1276             func media_ReadWord(), 1;                // read a word at the current stream position
1073  1277             // Syntax: media_ReadWord();
1074  1278             // Usage : var := media_ReadWord();
1075  1279             // *Notes : Reads and Returns a single word of data from the
1076  1280             //       : uSD card pointed to by the internal Address pointer.
1077  1281             //       : After the read the Address pointer is automatically
1078  1282             //       : incremented by 2.
1079  1283   
1080  1284             func media_WriteByte("byte"), 1;              // write a byte to the current stream position
1081  1285             // Syntax: media_WriteByte(arg1);
1082  1286             // Usage : var := media_WriteByte(arg1);
1083  1287             // *Notes : Writes and Returns xxxxx
1084  1288             //       : After the write the Address pointer is automatically
1085  1289             //       : incremented by 1.
1086  1290   
1087  1291             func media_WriteWord("word"), 1;            // write a word to the current stream position
1088  1292             // Syntax: media_WriteWord(arg1);
1089  1293             // Usage : var := media_WriteWord(arg1);
1090  1294             // *Notes : Writes and Returns xxxxx
1091  1295             //       : After the write the Address pointer is automatically
1092  1296             //       : incremented by 2.
1093  1297   
1094  1298             func media_Image("x", "y"), 0;            // display image at position x y
1095  1299             // Syntax: media_Image(x, y);
1096  1300             // Usage : media_Image(arg1, arg2);
1097  1301             // Notes : Display an image from the uSD card at screen location
1098  1302             //       : specified by x,y (top left corner). The location of the
1099  1303             //       : Image in the uSD card must be specified by
1100  1304             //       : media_setSector(Image_Sector_Add) function.
1101  1305   
1102  1306             func media_Flush(), 1;                    // after writing to media, flush the sector and write
1103  1307             // Syntax: media_Flush();
1104  1308             // Usage : var := media_Flush();
1105  1309             // *Notes : After writing any data to a sector, media_Flush() should be called to ensure that the current sector that
1106  1310             //       : is being written is correctly stored back to the media else write operations may be unpredictable.
1107  1311   
1108  1312             func media_Init(), 1;                    // initialize uSD card
1109  1313             // Usage : media_Init();
1110  1314             // Notes : Initialise uSD CARD
1111  1315             //       : Response: 0 = No Card
1112  1316             //       :           1 = Card Initialised
1113  1317   
1114  1318   
1115  1319             //==============================================//
1116  1320             // Communications Function Prototypes           //
1117  1321             //==============================================//
1118  1322             func com_Init("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
1119  1323             // Syntax: com_Init(buffer, bufsize, qualifier);
1120  1324             // Usage1: com_Init(mybuf, 20, 0);
1121  1325             // Usage2: com_Init(mybuf, 20, ':');
1122  1326             // Notes : initialize a serial capture buffer for the comms input
1123  1327             //       : The program must declare a var array as a circular buffer.
1124  1328             //       : Usage1 declares a circular buffer which will continually
1125  1329             //       : buffer characters.
1126  1330             //       : Usage2 must receive ':' before any characters will
1127  1331             //       : accumulate in the buffer.
1128  1332   
1129  1333             func com_Reset(), 0;                 // reset the comms receiver
1130  1334             // Syntax: com_Reset();
1131  1335             // Usage : com_Reset();
1132  1336             // Notes : reset comms to default polled mode
1133  1337   
1134  1338             func com_Count(), 1;                // return count of characters in receive buffer
1135  1339             // Syntax: com_Count();
1136  1340             // Usage : arg := com_Count();
1137  1341             // Notes : return count of buffered characters in buffer attachment
1138  1342   
1139  1343             func com_Full(), 1;                // return TRUE if receiver buffer filled to capcity
1140  1344             // Syntax: com_Full();
1141  1345             // Usage : if (com_Full() ,,,, go read buffer;
1142  1346             // Notes : return true if buffer full (not necessarily an error if
1143  1347             //       : buffer is sized to a packet size)
1144  1348   
1145  1349             func com_Error(), 1;                // return comms errors comms error occurred
1146  1350             // Syntax: com_Error();
1147  1351             // Usage : if (com_Error() ) ...... take recovery action;
1148  1352             // Notes : return non zero if any errors low level comms errors occured
1149  1353             // returns :
1150  1354             // bit0 = Receiver Overflow Error
1151  1355             // bit1 = Receiver Framing Error
1152  1356             // bit2 = Transmit Buffer Overflow
1153  1357   
1154  1358             func com_Sync(), 1;                // returns TRUE if qualifier has been received
1155  1359             // Syntax: com_Sync();
1156  1360             // Usage : com_Sync();
1157  1361             // return true if sync character has been received in com_Init("...") mode
1158  1362   
1159  1363   
1160  1364             func com_TXbuffer("buf", "bufsize"), 0;    // sets the buffer location for buffered transmission
1161  1365             // Syntax: com_TXbuffer("buf", "bufsize");
1162  1366             // Usage : com_TXbuffer(mybuf, 1024);       // set the TX buffer
1163  1367             // Usage : com_TXbuffer(0, 0);              // revert to non buffered service
1164  1368             // Notes : initialize a serial buffer for the COM0 output.
1165  1369             //       : The program must declare a var array as a circular buffer.
1166  1370             //       : When a TX buffer is declared for comms, the transmission
1167  1371             //       : of characters becomes non blocking. The only time
1168  1372             //       : blocking will occur is if the buffer has insufficient space
1169  1373             //       : to accet the next character, in which case the function
1170  1374             //       : will wait for buffer space to become available. If the
1171  1375             //       : TX buffer is no longer required, just set the buffer pointer
1172  1376             //       : to zero, the size in this case doesnt matter and is ignored.
1173  1377             //       : The function can resize or reallocated to another buffer at
1174  1378             //       : any time. The buffer is flushed before any changes are made.
1175  1379   
1176  1380             func com_TXcount(), 1;                // return count of characters in COM0 TX buffer
1177  1381             // Syntax: com_TXcount();
1178  1382             // Usage : arg := com_Count();
1179  1383             // Notes : return count of characters remaining in COM0 transmit buffer
1180  1384             //       : that was previously allocated with com_TXbuffer(...);
1181  1385   
1182  1386             func com_TXemptyEvent("function"), 1;  // sets a function to be called when COM0 TX buffer empty
1183  1387             // Syntax: com_TXemptyEvent(function);
1184  1388             // Usage : arg := com_TXemptyEvent();
1185  1389             // Notes : If a comms TX buffer that was previously allocated with
1186  1390             //       : com_TXbuffer(...);, this function can be used to set up
1187  1391             //       : a function to be called when the COM0 TX buffer is empty.
1188  1392             //       : This is useful for either reloading the TX buffer, setting
1189  1393             //       : or clearing a pin to change the direction of eg a RS485
1190  1394             //       : line driver, or any other form of traffic control.
1191  1395             //       : The event function must not have any parameters.
1192  1396             //       : To disable the event, simply call com_TXemptyEvent(0).
1193  1397             //       : com_TXbuffer(...); also resets any active event.
1194  1398             //       : com_TXemptyEvent returns any previous event function
1195  1399             //       : address, or zero if there was no previous function.
1196  1400   
1197  1401             func com_TXbufferHold("state"), 1; // hold or release a com_TXbuffer
1198  1402             // Usage : arg := com_TXbufferHold(ON);  // hold the buffer while we fill it
1199  1403             // Usage : arg := com_TXbufferHold(OFF);  // start sending the buffer
1200  1404             // Notes : Expecting that a comms TX buffer that was previously allocated with
1201  1405             //       : com_TXbuffer(...);, com_TXbufferHold(ON) can be used to stop
1202  1406             //       : the buffer being sent wile it is being loaded. Mormally, when
1203  1407             //       : using buffered comms, the transmit process will begin
1204  1408             //       : immediately. This is often undesirable for 2 reasons,
1205  1409             //       : 1] you may wish to build a packet then send it later
1206  1410             //       : 2] when using com_TXemptyEvent erroneous empty events will occur
1207  1411             //       : as the FIFO buffer is constantly trying to empty while
1208  1412             //       : you are busy tring to fill it.
1209  1413             // return -1 if function is called illegally when TX comms is not buffered.
1210  1414             // return buffer count when called with argument of 1, eg com_TXbufferHold(ON)
1211  1415             // return 0 when argument is zero, eg com_TXbufferHold(OFF)
1212  1416   
1213  1417   
1214  1418             //=============================================================//
1215  1419             // Auxilliary Communications Function Prototypes
1216  1420             //=============================================================//
1217  1421             func com1_Init("buffer", "bufsize", "qualifier"), 0;
1218  1422             // Syntax: com_Init(buffer, bufsize, qualifier);
1219  1423             // Usage1: com_Init(mybuf, 20, 0);
1220  1424             // Usage2: com_Init(mybuf, 20, ':');
1221  1425             // Notes : initialize a serial capture buffer for the comms input
1222  1426             //       : The program must declare a var array as a circular buffer.
1223  1427             //       : Usage1 declares a circular buffer which will continually
1224  1428             //       : buffer characters.
1225  1429             //       : Usage2 must receive ':' before any characters will
1226  1430             //       : accumulate in the buffer.
1227  1431   
1228  1432             func com1_Reset(), 0;
1229  1433             // Syntax: com_Reset();
1230  1434             // Usage : com_Reset();
1231  1435             // Notes : reset comms receiver to default polled mode
1232  1436   
1233  1437             func com1_Count(), 1;
1234  1438             // Syntax: com_Count();
1235  1439             // Usage : arg := com_Count();
1236  1440             // Notes : return count of characters in receive buffer
1237  1441   
1238  1442             func com1_Full(), 1;
1239  1443             // Syntax: com_Full();
1240  1444             // Usage : if (com_Full() ,,,, go read buffer;
1241  1445             // Notes : return true if receive buffer full
1242  1446   
1243  1447             func com1_Error(), 1;
1244  1448             // Syntax: com_Error();
1245  1449             // Usage : if (com_Error() ) ...... take recovery action;
1246  1450             // Notes : return non zero if any level comms errors occured
1247  1451             // returns :
1248  1452             // bit0 = Receiver Overflow Error
1249  1453             // bit1 = Receiver Framing Error
1250  1454             // bit2 = Transmit Buffer Overflow
1251  1455   
1252  1456             func com1_Sync(), 1;
1253  1457             // Syntax: com_Sync();
1254  1458             // Usage : com_Sync();
1255  1459             // Notes : return true if sync character has been received in com_Init("...") mode
1256  1460   
1257  1461   
1258  1462             func com1_TXbuffer("buf", "bufsize"), 0;    // sets the buffer location for buffered transmission
1259  1463             // Syntax: com1_TXbuffer("buf", "bufsize");
1260  1464             // Usage : com1_TXbuffer(mybuf, 1024);
1261  1465             // Usage : com1_TXbuffer(0, 0);              // revert to non buffered service
1262  1466             // Notes : initialize a serial buffer for the COM1 output.
1263  1467             //       : The program must declare a var array as a circular buffer.
1264  1468             //       : When a TX buffer is declared for comms, the transmission
1265  1469             //       : of characters becomes non blocking. The only time
1266  1470             //       : blocking will occur is if the buffer has insufficient space
1267  1471             //       : to accet the next character, in which case the function
1268  1472             //       : will wait for buffer space to become available. If the
1269  1473             //       : TX buffer is no longer required, just set the buffer pointer
1270  1474             //       : to zero, the size in this case doesnt matter and is ignored.
1271  1475             //       : The function can resize or reallocated to another buffer at
1272  1476             //       : any time. The buffer is flushed before any changes are made.
1273  1477   
1274  1478             func com1_TXcount(), 1;                // return count of characters in COM1 TX buffer
1275  1479             // Syntax: com1_TXcount();
1276  1480             // Usage : arg := com1_Count();
1277  1481             // Notes : return count of characters remaining in COM1 transmit buffer
1278  1482             //       : that was previously allocated with com1_TXbuffer(...);
1279  1483   
1280  1484             func com1_TXemptyEvent("function"), 1;  // sets a function to be called when COM1 TX buffer empty
1281  1485             // Syntax: com1_TXemptyEvent(function);
1282  1486             // Usage : arg := com1_TXemptyEvent();
1283  1487             // Notes : If a comms TX buffer that was previously allocated with
1284  1488             //       : com1_TXbuffer(...);, this function can be used to set up
1285  1489             //       : a function to be called when the COM1 TX buffer is empty.
1286  1490             //       : This is useful for either reloading the TX buffer, setting
1287  1491             //       : or clearing a pin to change the direction of eg a RS485
1288  1492             //       : line driver, or any other form of traffic control.
1289  1493             //       : The event function must not have any parameters.
1290  1494             //       : To disable the event, simply call com1_TXemptyEvent(0).
1291  1495             //       : com1_TXbuffer(...); also resets any active event.
1292  1496             //       : com1_TXemptyEvent returns any previous event function
1293  1497             //       : address, or zero if there was no previous function.
1294  1498   
1295  1499             func com1_TXbufferHold("state"), 1; // hold or release a com1_TXbuffer
1296  1500             // Usage : arg := com1_TXbufferHold(ON);  // hold the buffer while we fill it
1297  1501             // Usage : arg := com1_TXbufferHold(OFF);  // start sending the buffer
1298  1502             // Notes : Expecting that a comms TX buffer that was previously allocated with
1299  1503             //       : com1_TXbuffer(...);, com1_TXbufferHold(ON) can be used to stop
1300  1504             //       : the buffer being sent wile it is being loaded. Mormally, when
1301  1505             //       : using buffered comms, the transmit process will begin
1302  1506             //       : immediately. This is often undesirable for 2 reasons,
1303  1507             //       : 1] you may wish to build a packet then send it later
1304  1508             //       : 2] when using com_TXemptyEvent erroneous empty events will occur
1305  1509             //       : as the FIFO buffer is constantly trying to empty while
1306  1510             //       : you are busy tring to fill it.
1307  1511             // return -1 if function is called illegally when TX comms is not buffered.
1308  1512             // return buffer count when called with argument of 1, eg com1_TXbufferHold(ON)
1309  1513             // return 0 when argument is zero, eg com1_TXbufferHold(OFF)
1310  1514   
1311  1515             func serin1(), 1;
1312  1516             // Syntax: serin1();
1313  1517             // Usage : char := serin1();
1314  1518             // Notes : return the next available character from COM1
1315  1519   
1316  1520             func serout1("char"), 0;
1317  1521             // Syntax: serout1("char");
1318  1522             // Usage : serout1(ch);
1319  1523             // Notes : send character to COM1
1320  1524   
1321  1525             func com_SetBaud("comport","baudrate/10"), 1;
1322  1526             // Syntax: com_SetBaud("comport","baudrate/10");
1323  1527             // Usage : com_SetBaud(COM1, 960);   // set COM1 to 9600 baud
1324  1528             // Notes : sets to any viable baud rate from 160 to 655350
1325  1529             // return true if baud rate was acceptable
1326  1530   
1327  1531   
1328  1532   
1329  1533             //==============================================//
1330  1534             // Display Access                               //
1331  1535             //==============================================//
1332  1536             func disp_Init("INIT_table", "GRAM_code"), 0;   // initialize display with required tables
1333  1537                                                             // NB not available on current Picaso GFX2
1334  1538   
1335  1539             func disp_SetReg("register", "data"), 0;
1336  1540             // Syntax: display_SetReg(register, data);
1337  1541             // Usage : display_SetReg(arg1, arg2);
1338  1542             // Notes : Sets uLCD specific display driver registers. Refer
1339  1543             //       : to appropriate display driver data sheet.
1340  1544   
1341  1545             func disp_setGRAM("x1","y1","x2","y2"), 0;    // set GRAM window
1342  1546             // Syntax: disp_setGRAM(x1, y1, x2, y2);
1343  1547             // Usage : disp_setGRAM(arg1, arg2, arg3, arg4);
1344  1548             // Notes : Prepares the GRAM area for user access.
1345  1549             //       : Data can now be written with disp_GRAM.
1346  1550             //       : GRAM will be set accordingly for the correct screen mode.
1347  1551             //       : the LO word of the 32 bit pixel count is returned. This is
1348  1552             //       : usually all that is needed unlse GRAM area exceeds 256^2
1349  1553             //       : A copy of the 32bit value can be found in
1350  1554             //       : GRAM_PIXEL_COUNT_LO and GRAM_PIXEL_COUNT_HI
1351  1555   
1352  1556             func disp_WrGRAM("colour"), 0;
1353  1557             // Syntax: display_WrGRAM(colour);
1354  1558             // Usage : display_WrGRAM(arg);
1355  1559             // Notes : Data can be written to the GRAM consecutively using
1356  1560             //       : this function once the GRAM access window has been setup.
1357  1561   
1358  1562             func disp_WriteControl("value"), 0;             // write a control byte to the display
1359  1563             func disp_WriteWord("value"), 0;                // write a word to the display
1360  1564             func disp_ReadWord(), 1;                        // read a word from the display
1361  1565   
1362  1566                                                             //
1363  1567             //==============================================//
1364  1568             // unadorned SPI functions                      //
1365  1569             //==============================================//
1366  1570             func spi_Init("speed","ip_mode","op_mode"), 0;  // set the SPI port, not used if uSD active
1367  1571             func spi_Read(), 1;                             // read a raw byte from SPI (lowers CS)
1368  1572             func spi_Write("byte"), 0;                      // write a raw byte to SPI (lowers CS)
1369  1573             func spi_Disable(), 0;                          // disable SPI reading or writing (raise CS)
1370  1574                                                             //
1371  1575             //==============================================//
1372  1576             // flash device specific functions              //
1373  1577             //==============================================//
1374  1578             func flash_SIG(), 1;                            // read Jedecsignature from SPI Flash device
1375  1579             func flash_ID(), 1;                             // read ID code from FLASH device
1376  1580             func flash_BulkErase(), 0;                      // erase the entire FLASH device
1377  1581             func flash_BlockErase("block"), 1;              // erase the required 64k flash block
1378  1582                                                             //
1379  1583                                                             //
1380  1584             //==============================================//
1381  1585             // string and character size function           //
1382  1586             //==============================================//
1383  1587             func charwidth("char"), 1;                      // return width of a character in pixel units
1384  1588             func charheight("char"), 1;                     // return height of a character in pixel units
1385  1589             func strwidth("pointer"), 1;                    // return width of a string in pixel units
1386  1590             func strheight(), 1;                            // return height of a string in pixel units
1387  1591   
1388  1592   
1389  1593             //------------------------------------------------------------------//
1390  1594             //        I2C Function Prototypes
1391  1595             //------------------------------------------------------------------//
1392  1596             func I2C_Open("speed"), 0;
1393  1597             // Syntax: I2C_Open(speed),
1394  1598             // Usage : I2C_Open(I2C_MED);
1395  1599             // Notes : configures the I2C module
1396  1600             //       : speed can be I2C_SLOW, I2C_MED, I2C_FAST (100khz, 400khz, 1mhz)
1397  1601   
1398  1602             func I2C_Close(), 0;
1399  1603             // Syntax: I2C_Close();
1400  1604             // Usage : I2C_Close();
1401  1605             // Notes : disables the I2C1 module.
1402  1606   
1403  1607             func I2C_Start(), 1;
1404  1608             // Syntax: I2C_Start();
1405  1609             // Usage : I2C_Start();
1406  1610             // Notes : generates a Start condition.
1407  1611             //       : returns true if successful (usually ignored)
1408  1612   
1409  1613             func I2C_Stop(), 1;
1410  1614             // Syntax: I2C_Stop();
1411  1615             // Usage : I2C_Stop();
1412  1616             // Notes : generates a Stop condition.
1413  1617             //       : returns true if successful (usually ignored)
1414  1618   
1415  1619             func I2C_Restart(), 1;
1416  1620             // Syntax: I2C_Restart();
1417  1621             // Usage : I2C_Restart();
1418  1622             // Notes : generates a Restart condition.
1419  1623             //       : returns true if successful (usually ignored)
1420  1624   
1421  1625             func I2C_Read(), 1;
1422  1626             // Syntax: I2C_Read();
1423  1627             // Usage : ch := I2C_Read();
1424  1628             // Notes : reads a single byte from the I2C Bus.
1425  1629   
1426  1630             func I2C_Write("byte"), 1;
1427  1631             // Syntax: I2C_Write(byte);
1428  1632             // Usage : r := I2C_Write(ch);
1429  1633             // Notes : is used to write a byte to the I2C bus.
1430  1634             //       : Returns 0 if failed, 1 if no ack, 2 if ack
1431  1635   
1432  1636             func I2C_Ack(), 0;
1433  1637             // Syntax: I2C_Ack();
1434  1638             // Usage : I2C_Ack();
1435  1639             // Notes : generates the acknowledge condition.
1436  1640   
1437  1641             func I2C_Nack(), 0;
1438  1642             // Syntax: I2C_Nack();
1439  1643             // Usage : I2C_Nack();
1440  1644             // Notes : generates the negative acknowledge condition.
1441  1645   
1442  1646             func I2C_AckStatus(), 0;
1443  1647             // Syntax: I2C_AckStatus();
1444  1648             // Usage : r := I2C_AckStatus();
1445  1649             // Notes : returns the ACK status from the device.
1446  1650   
1447  1651             func I2C_AckPoll("control"), 1;
1448  1652             // Syntax: I2C_AckPoll();
1449  1653             // Usage : r := I2C_AckPoll(0xA0);
1450  1654             // Notes : waits for a device to return from ACK polling.
1451  1655   
1452  1656             func I2C_Idle(), 0;
1453  1657             // Syntax: I2C_Idle();
1454  1658             // Usage : I2C_Idle();
1455  1659             // Notes : waits until the I2C Bus is Inactive.
1456  1660   
1457  1661             func I2C_Gets("buffer", "size"), 1;
1458  1662             // Syntax: I2C_Gets("buffer", "size");
1459  1663             // Usage : r := I2C_Gets(mybuf, 16);
1460  1664             // Notes : only reads up to "size" characters into "buffer"
1461  1665             //       : Reads up to asciiz terminator including terminator
1462  1666   
1463  1667             func I2C_Getn("buffer", "size"), 1;
1464  1668             // Syntax: I2C_Gets("buffer", "size");
1465  1669             // Usage : r := I2C_Gets(mybuf, 16);
1466  1670             // Notes : reads "size" bytes into "buffer"
1467  1671             //       :
1468  1672   
1469  1673             func I2C_Puts("buffer"), 1;
1470  1674             // Syntax: I2C_Puts("buffer");
1471  1675             // Usage : r := I2C_Puts(mybuf);
1472  1676             // Notes : writes an asciiz string to the I2C device
1473  1677             //       : returns count of characters written
1474  1678   
1475  1679             func I2C_Putn("buffer", "count"), 1;
1476  1680             // Syntax: I2C_Puts("buffer");
1477  1681             // Usage : r := I2C_Puts(mybuf);
1478  1682             // Notes : writes up to "size" bytes to the I2C device
1479  1683             //       : returns number of bytes written
1480  1684   
1481  1685   
1482  1686             //------------------------------------------------------------------//
1483  1687             //        Image Control Function Prototypes
1484  1688             //------------------------------------------------------------------//
1485  1689             func img_SetPosition("handle", "index", "xpos", "ypos"), 1;
1486  1690             // Syntax: img_SetPosition(handle, index, xpos, ypos);
1487  1691             // Usage : r := img_SetPosition(hImageList, imagenum, x, y);
1488  1692             // Notes : set the position where the image will be displayed
1489  1693             //       : returns true if index was ok and function was successful.
1490  1694             //       : you may turn off an image so when img_Refresh is called,
1491  1695             //       : the image will not be shown
1492  1696   
1493  1697             func img_Enable("handle", "index"), 1;
1494  1698             // Syntax: img_Enable(handle, index);
1495  1699             // Usage : r := img_Enable(hImageList, imagenum);
1496  1700             // Notes : enable image in a image list
1497  1701             //       : returns true if index was ok and function was successful.
1498  1702             //       : this is the default state so when img_Refresh is called,
1499  1703             //       : all the images in the list will be shown
1500  1704             //       : if index is set to -1, all of the images are enabled
1501  1705   
1502  1706             func img_Disable("handle", "index"), 1;
1503  1707             // Syntax: img_Disable(handle, index);
1504  1708             // Usage : r := img_Disable(hImageList, imagenum);
1505  1709             // Notes : disable image in a image list
1506  1710             //       : returns true if index was ok and function was successful.
1507  1711             //       : you must turn off an image so when img_Refresh is called,
1508  1712             //       : the image will not be shown.
1509  1713             //       : if index is set to -1, all of the images are disabled
1510  1714   
1511  1715   
1512  1716             func img_Darken("handle", "index"), 1;
1513  1717             // Syntax: img_Darken(handle, index);
1514  1718             // Usage : r := img_Darken(hImageList, imagenum);
1515  1719             // Notes : darken image in a image list
1516  1720             //       : returns true if index was ok and function was successful.
1517  1721             //       : if index is set to -1, all of the images are darkened
1518  1722             //       : NB:- this feature will only work for the next refresh, then
1519  1723             //       : the image reverts back to normal when displayed again.
1520  1724   
1521  1725   
1522  1726             func img_Lighten("handle", "index"), 1;
1523  1727             // Syntax: img_Lighten(handle, index);
1524  1728             // Usage : r := img_Lighten(hImageList, imagenum);
1525  1729             // Notes : lighten image in a image list
1526  1730             //       : returns true if index was ok and function was successful.
1527  1731             //       : if index is set to -1, all of the images are lightened
1528  1732             //       : NB:- this feature will only work for the next refresh, then
1529  1733             //       : the image reverts back to normal when displayed again.
1530  1734   
1531  1735             func img_SetWord("handle", "index", "offset", "word"), 1;
1532  1736             // Syntax: img_SetWord(handle, index, offset, word);
1533  1737             // Usage : img_SetWord(hndl, 5, IMAGE_XPOS, 10);
1534  1738             // Notes : set specified word (0-7) in a image entry
1535  1739             //       : returns TRUE if successful, return value usually ignored.
1536  1740   
1537  1741             func img_GetWord("handle", "index", "offset"), 1;
1538  1742             // Syntax: myvar := img_GetWord("handle", "index", "offset");
1539  1743             // Usage : myvar := img_GetWord(hndl, 5, IMAGE_YPOS);
1540  1744             // Notes : returns specified word (0-14) from an image entry
1541  1745             //       : refer to image control entry offsets.
1542  1746   
1543  1747             func img_Show("handle", "index"), 1;
1544  1748             // Syntax: img_Show(handle, index);
1545  1749             // Usage : display image entry (regardless of enable/disable)
1546  1750             //       : returns TRUE if successful, return value usually ignored.
1547  1751   
1548  1752             func img_SetAttributes("handle", "index","value"), 1;
1549  1753             // Syntax: img_SetAttributes("handle", "index","offset");
1550  1754             // Usage : img_SetAttributes(hndl, 5, I_TOPMOST);
1551  1755             // Notes : This function SETS one or more bits in the IMAGE_FLAGS field
1552  1756             //       : of an image control entry. "value" refers to various bits in
1553  1757             //       : the image control entry (see image attribute flags).
1554  1758             //       : A '1' bit in the "value" field SETS the respective bit
1555  1759             //       : in the IMAGE_FLAGS field of the image control entry.
1556  1760             //       : returns TRUE if successful, return value usually ignored.
1557  1761   
1558  1762             func img_ClearAttributes("handle", "index","value"), 1;
1559  1763             // Syntax: img_ClearAttributes("handle", "index","offset");
1560  1764             // Usage : img_ClearAttributes(hndl, 5, I_TOPMOST);
1561  1765             // Notes : This function CLEARS one or more bits in the IMAGE_FLAGS field
1562  1766             //       : of an image control entry. "value" refers to various bits in
1563  1767             //       : the image control entry (see image attribute flags)
1564  1768             //       : a '1' bit in the "value" field CLEARS the respective bit
1565  1769             //       : in the IMAGE_FLAGS field of the image control entry.
1566  1770             //       : returns TRUE if successful, return value usually ignored.
1567  1771   
1568  1772             func img_Touched("handle", "index"), 1;
1569  1773             // Syntax: r := img_Touched(handle, index);
1570  1774             // Usage : img_Touched(hndl, 17);
1571  1775             //       : returns -1 if image not touched, or returns index
1572  1776             // Notes : if index is passed as -1, function tests all images,
1573  1777             //       : and returns -1 if image not touched, or returns index.
1574  1778   
1575  1779   
1576  1780   
1577  1781   
1578  1782             //------------------------------------------------------------------//
1579  1783             //        Timer Function Prototypes
1580  1784             //------------------------------------------------------------------//
1581  1785             func sys_T(), 1;
1582  1786             // Syntax: sys_T();
1583  1787             // Usage : t := sys_T();
1584  1788             // Notes : return the current value of the rolling system timer (1msec) LO word
1585  1789   
1586  1790             func sys_T_HI(), 1;
1587  1791             // Syntax: sys_T_HI();
1588  1792             // Usage : t := sys_T_HI();
1589  1793             // Notes : return the current value of the rolling system timer (1msec) HI word
1590  1794   
1591  1795             func sys_SetTimer("timernum","value"), 0;
1592  1796             // Syntax: sys_SetTimer("timernum", "value");
1593  1797             // Usage : sys_SetTimer(TIMER5, 10000);
1594  1798             // Notes : set a countdown on the selected timer, or 'top up' if required.
1595  1799             //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
1596  1800             //       : Maximum timeout period is 65.535 seconds
1597  1801             //       : A timer can be read with the sys_GetTimer("timernum") function
1598  1802   
1599  1803             func sys_GetTimer("timernum"), 1;
1600  1804             // Syntax: t := sys_GetTimer("timernum");
1601  1805             // Usage : t := sys_GetTimer(TIMER3);
1602  1806             // Notes : returns 0 if timer has expired, or the current countdown value.
1603  1807             //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
1604  1808             //       : Maximum timeout period is 65.535 seconds
1605  1809             //       : A timer must be set with the sys_SetTimer("timernum","value") function
1606  1810   
1607  1811             func sys_SetTimerEvent("timernum","function"), 1;
1608  1812             // Syntax: sys_SetTimerFunction("timernum", "function");
1609  1813             // Usage : sys_SetTimer(TIMER5, myfunc);
1610  1814             // Notes : set a function to be called for selected timer.
1611  1815             //       : When the timer reaches zero, the function is called.
1612  1816             //       : The called function must not have any parameters
1613  1817             //       : sys_SetTimerEvent returns any previous event function
1614  1818             //       : address, or zero if there was no previous function.
1615  1819   
1616  1820             func sys_EventQueue(), 1;
1617  1821             // Syntax: sys_EventQueue();
1618  1822             // Usage : tasks := sys_EventQueue();
1619  1823             // Notes : returns the max number of events that were pending
1620  1824             //       : in the timer queue since the last call to this function.
1621  1825             //       : This can be used to assess timer event overhead burden,
1622  1826             //       : especially after or during a sys_EventsPostpone action.
1623  1827   
1624  1828             func sys_EventsPostpone(), 0;
1625  1829             // Syntax: sys_EventPostpone();
1626  1830             // Usage : sys_EventPostpone();   // postpone the event queue
1627  1831             // Notes : postpone any events until the sys_EventResume function is executed
1628  1832             //       : The timer event queue will continue to queue events, but no action
1629  1833             //       : will take place untill a sys_EventResume function is encountered.
1630  1834             //       : The queue will continue to receive up to 32 events before discarding
1631  1835             //       : any further events. This function is required to allow a sequence of
1632  1836             //       : instructions or functions to occur that would otherwise be corrupted
1633  1837             //       : by an event occuring during the sequence of instructions or functions.
1634  1838             //       : A good example of this is when you set a position to print, if there
1635  1839             //       : was no way of locking the current sequence, an event may occur which
1636  1840             //       : does a similar thing, and a contention would occur - printing to
1637  1841             //       : the wrong position. This function should be used wisely, if any action
1638  1842             //       : that is required would take considerable time, it is better to disable
1639  1843             //       : any conflicting event functions with a bypass flag, then restart the
1640  1844             //       : conflicting event by re-issuing a timer value.
1641  1845   
1642  1846             func sys_EventsResume(), 0;
1643  1847             // Syntax: sys_EventsResume();
1644  1848             // Usage : sys_EventsResume();   // resume the event queue
1645  1849             // Notes : resume any postponed events. The queue will try to execute any timer
1646  1850             //       : events that were incurred during the postponed period.
1647  1851   
1648  1852   
1649  1853             func sys_Sleep("units"), 1;
1650  1854             // Syntax: t := sys_Sleep("units");
1651  1855             // Usage : t := sys_Sleep(10);
1652  1856             // Notes : sets the display into low power mode for a period of time.
1653  1857             //       : Touching the touch screen will also wake from sleep.
1654  1858             //       : Returns remaining sleep units.
1655  1859   
1656  1860             func iterator("offset"), 0;
1657  1861             // Syntax: t :=  iterator("offset");
1658  1862             // Usage : t :=  iterator(10);
1659  1863             // Notes : set the iterator size for ++/--
1660  1864             //       : The next postinc,postdec,preinc of predec will alter
1661  1865             //       : by the specified value.
1662  1866             //       : The offset will return to 1 after the next operation.
1663  1867   
1664  1868   
1665  1869   
1666  1870   
1667  1871             //------------------------------------------------------------------//
1668  1872             //         Touch Screen Function Prototypes
1669  1873             //------------------------------------------------------------------//
1670  1874   
1671  1875             func touch_DetectRegion("x1" ,"y1", "x2", "y2"), 0;
1672  1876             // Syntax: touch_DetectRegion(x1, y1, x2, y2);
1673  1877             // Usage : touch_DetectRegion(arg1, arg2, arg3, arg4);
1674  1878             // Notes : Specifies a new touch detect region on the screen
1675  1879             //       : such that only touch activity in that region will
1676  1880             //       : be reported by the status poll touch_Get(0);
1677  1881   
1678  1882             func touch_Set("mode"), 0;
1679  1883             // Syntax: touch_Set(mode);
1680  1884             // Usage : touch_Set(arg);
1681  1885             // Notes : Sets various Touch Screen related parameters
1682  1886             //       :
1683  1887             //       : mode = TOUCH_ENABLE (mode 0)  Enable Touch Screen
1684  1888             //       : touch_Set(TOUCH_ENABLE);
1685  1889             //       : Enables and initialises Touch Screen hardware
1686  1890             //       :
1687  1891             //       : mode = TOUCH_DISABLE (mode 1)  Disable Touch Screen
1688  1892             //       : touch_Set(TOUCH_DISABLE );
1689  1893             //       : Disables the Touch Screen
1690  1894             //       : Note: Touch Screen runs in the background and disabling
1691  1895             //       : it when not in use will free up extra resources
1692  1896             //       : such as 4DVM CPU cycles.
1693  1897             //       :
1694  1898             //       : mode = TOUCH_REGIONDEFAULT (mode 2)  Default Touch Region
1695  1899             //       : touch_Set(TOUCH_REGIONDEFAULT);
1696  1900             //       : This will reset the current active region to default
1697  1901             //       : to the full screen without the application having to
1698  1902             //       : set a new active region for the full screen.
1699  1903   
1700  1904             func touch_Get("mode"), 1;
1701  1905             // Syntax: touch_Get(mode);
1702  1906             // Usage : arg1 := touch_Get(arg);
1703  1907             // Notes : Returns various Touch Screen parameters to caller
1704  1908             //       :
1705  1909             //       : mode = TOUCH_STATUS  (mode 0)
1706  1910             //       : var := touch_Get(TOUCH_STATUS);
1707  1911             //       : Returns the various states of the touch screen
1708  1912             //       : 0 = NOTOUCH
1709  1913             //       : 1 = TOUCH_PRESSED
1710  1914             //       : 2 = TOUCH_RELEASED
1711  1915             //       : 3 = TOUCH_MOVING
1712  1916             //       :
1713  1917             //       : mode = TOUCH_GETX   (mode 1)
1714  1918             //       : var := touch_Get(TOUCH_GETX);
1715  1919             //       : Returns the X coordinates of the touch
1716  1920             //       :
1717  1921             //       : mode = TOUCH_GETY   (mode 2)
1718  1922             //       : var := touch_Get(TOUCH_GETY);
1719  1923             //       : Returns the Y coordinates of the touch
1720  1924   
1721  1925             //------------------------------------------------------------------//
1722  1926             //        CTYPE Function Prototypes
1723  1927             //------------------------------------------------------------------//
1724  1928   
1725  1929             func isdigit("char"), 1;    //Returns a 1 if the character is an ascii digit else returns a 0
1726  1930             // Syntax: isdigit("char");
1727  1931             // Usage : Var := isdigit(ch);
1728  1932             // Notes : char specifies the ascii character for the test
1729  1933             //     : 0 : char is not an ascii digit.
1730  1934             //     : 1 : char is an ascii digit..
1731  1935             //     : Valid range is "0123456789"
1732  1936   
1733  1937             func isxdigit("char"), 1;    //Returns a 1 if the character is an ascii hexadecimal digit else returns a 0
1734  1938             // Syntax: isxdigit("char");
1735  1939             // Usage : Var := isxdigit(ch);
1736  1940             // Notes : char specifies the ascii character for the test
1737  1941             //     : 0 : char is not an ascii hexadecimal digit.
1738  1942             //     : 1 : char is an ascii hexadecimal digit..
1739  1943             //     : Valid range is "0123456789ABCDEF"
1740  1944   
1741  1945             func isupper("char"), 1;    //Returns a 1 if the character is an ascii upper case letter else returns a 0
1742  1946             // Syntax: isupper("char");
1743  1947             // Usage : Var := isupper(ch);
1744  1948             // Notes : char specifies the ascii character for the test
1745  1949             //     : 0 : char is not an ascii upper-case letter.
1746  1950             //     : 1 : char is an ascii upper-case letter.
1747  1951             //     : Valid range is "ABCD....WXYZ"
1748  1952   
1749  1953             func islower("char"), 1;    //Returns a 1 if the character is an ascii lower case letter else returns a 0
1750  1954             // Syntax: islower("char");
1751  1955             // Usage : Var := islower(ch);
1752  1956             // Notes : char specifies the ascii character for the test
1753  1957             //     : 0 : char is not an ascii lower-case letter.
1754  1958             //     : 1 : char is an ascii lower-case letter.
1755  1959             //     : Valid range is "abcd....wxyz"
1756  1960   
1757  1961             func isalpha("char"), 1;    //Returns a 1 if the character is an ascii lower or upper case letter else returns a 0
1758  1962             // Syntax: isalpha("char");
1759  1963             // Usage : Var := isalpha(ch);
1760  1964             // Notes : char specifies the ascii character for the test
1761  1965             //     : 0 : char is not an ascii lower or upper case letter.
1762  1966             //     : 1 : char is an ascii lower or upper case letter.
1763  1967             //     : Valid range is "ABCD...XYZ", "abcd....wxyz"
1764  1968   
1765  1969             func isalnum("char"), 1;    //Returns a 1 if the character is an ascii alpha numeric else returns a 0
1766  1970             // Syntax: isalnum("char");
1767  1971             // Usage : Var := isalnum(ch);
1768  1972             // Notes : char specifies the ascii character for the test
1769  1973             //     : 0 : char is not an ascii alphanumeric character.
1770  1974             //     : 1 : char is an ascii alphanumeric character.
1771  1975             //     : Valid range is "ABCD...XYZ", "abcd....wxyz", "0123456789"
1772  1976   
1773  1977             func isprint("char"), 1;    //Returns a 1 if the character is a printible ascii char else returns a 0
1774  1978             // Syntax: isprint("char");
1775  1979             // Usage : Var := isprint(ch);
1776  1980             // Notes : char specifies the ascii character for the test
1777  1981             //     : 0 : char is not a printable ascii character.
1778  1982             //     : 1 : char is a printable ascii character.
1779  1983             //     : Valid range is "0x20...0x7F"
1780  1984   
1781  1985             func isspace("char"), 1;    //Returns a 1 if the character is any one of the space type chars else returns a 0
1782  1986             // Syntax: isspace("char");
1783  1987             // Usage : Var := isspace(ch);
1784  1988             // Notes : char specifies the ascii character for the test
1785  1989             //     : 0 : char is not a space type character.
1786  1990             //     : 1 : char is a space type character.
1787  1991             //     : Valid range is space, formfeed, newline, carriage return, tab, vertical tab
1788  1992   
1789  1993             //unformatted
1790  1994             func iswhite("char"), 1;    //
1791  1995             // Syntax: iswhite("char");
1792  1996             // Usage : Var := iswhite(ch);
1793  1997             // Notes : char specifies the ascii character for the test
1794  1998             //     : 0 : char is not a space or tab character.
1795  1999             //     : 1 : char is not a space or tab character.
1796  2000             //     : Valid range is space or tab
1797  2001   
1798  2002             func toupper("char"), 1; //if character is lower case it returns the upper case equivalent else returns the passed char
1799  2003             // Syntax: toupper("char");
1800  2004             // Usage : Var := toupper(ch);
1801  2005             // Notes : char specifies the ascii character for the test
1802  2006             //     : "ABCD....XYZ" : if character is a lower case letter.
1803  2007             //     : char : if character is not a lower case letter.
1804  2008             //     : Valid range is "abcd....wxyz"
1805  2009   
1806  2010             func tolower("char"), 1; //if character is upper case it returns the lower case equivalent else returns the passed char
1807  2011             // Syntax: tolower("char");
1808  2012             // Usage : Var := tolower(ch);
1809  2013             // Notes : char specifies the ascii character for the test
1810  2014             //     : "abcd....xyz" : if character is an upper case letter.
1811  2015             //     : char : if character is not an upper case letter.
1812  2016             //     : Valid range is "ABCD....WXYZ"
1813  2017   
1814  2018             func LObyte("var"), 1;        //Returns the lower byte (lower 8 bits) of a 16 bit variable.
1815  2019             // Syntax: LObyte(var);
1816  2020             // Usage : myVar := LObyte(myvar2);
1817  2021             // Notes : var specifies the user variable
1818  2022             //     : Returns the lower byte (lower 8 bits) of a 16 bit variable
1819  2023   
1820  2024             func HIbyte("var"), 1;        //Returns the High byte (upper 8 bits) of a 16 bit variable.
1821  2025             // Syntax: HIbyte(var);
1822  2026             // Usage : myVar := HIbyte(myvar2);
1823  2027             // Notes : var specifies the user variable
1824  2028             //     : Returns the high byte (upper 8 bits) of a 16 bit variable
1825  2029   
1826  2030   
1827  2031             func ByteSwap("var"), 1;    //Returns the swapped upper and lower bytes of a 16 bit variable.
1828  2032             // Syntax: ByteSwap(var);
1829  2033             // Usage : myVar := ByteSwap(myvar2);
1830  2034             // Notes : var specifies the user variable
1831  2035             //     : Returns the endian swapped value of a 16 bit variable
1832  2036   
1833  2037   
1834  2038             //------------------------------------------------------------------//
1835  2039             //        Memory Allocation Function Prototypes
1836  2040             //------------------------------------------------------------------//
1837  2041   
1838  2042             func mem_Alloc("size"), 1;
1839  2043             // Syntax: mem_Alloc(bytesize);
1840  2044             // Usage : myvar := mem_Alloc(100);
1841  2045             // Notes : Allocate a block of memory to pointer myvar
1842  2046             //       : The allocated memory contains garbage but is a fast allocation.
1843  2047             //       : The block must later be released with mem_Free();
1844  2048             //       : returns 0 if function fails
1845  2049   
1846  2050             func mem_AllocV("size"), 1;
1847  2051             // Syntax: mem_AllocV(bytesize);
1848  2052             // Usage : myvar := mem_AllocV(100);
1849  2053             // Notes : Allocate a block of memory to pointer myvar
1850  2054             //       : The block of memory is filled with signature values
1851  2055             //       : the block starts with A5,5A then fills with incrementing
1852  2056             //       : number eg:- A5,5A,00,01,02,03...FF,00,11....
1853  2057             //       : This can be helpful when debugging
1854  2058             //       : The block must later be released with mem_Free();
1855  2059             //       : returns 0 if function fails
1856  2060   
1857  2061             func mem_AllocZ("size"), 1;
1858  2062             // Syntax: mem_AllocZ(bytesize);
1859  2063             // Usage : myvar := mem_AllocC(100);
1860  2064             // Notes : Allocate a zeroed block of memory to pointer myvar
1861  2065             //       : The block of memory is filled with zeroes
1862  2066             //       : The block must later be released with mem_Free();
1863  2067             //       : returns 0 if function fails
1864  2068   
1865  2069             func mem_Realloc("ptr", "size"), 1;
1866  2070             // Syntax: myvar := mem_Realloc("ptr", "size");
1867  2071             // Usage : myvar := mem_Realloc(ptr, size);
1868  2072             // Notes : The function may move the memory block to a new location,
1869  2073             //       : in which case the new location is returned.
1870  2074             //       : The content of the memory block is preserved up to the lesser
1871  2075             //       : of the new and old sizes, even if the block is moved.
1872  2076             //       : If the new size is larger, the value of the newly allocated
1873  2077             //       : portion is indeterminate. In case that ptr is NULL,
1874  2078             //       : the function behaves exactly as mem_Alloc, assigning a new block
1875  2079             //       : of size bytes and returning a pointer to the beginning of it.
1876  2080             //       : In case that the size is 0, the memory previously allocated in
1877  2081             //       : ptr is deallocated as if a call to mem_Free()was made, and a NULL
1878  2082             //       : pointer is returned.
1879  2083   
1880  2084             func mem_Free("allocation"), 1;
1881  2085             // Syntax: myvar := mem_Free(allocation);
1882  2086             // Usage : myvar := mem_Free(myvar);
1883  2087             // Notes : De-allocate a block of memory previously created with
1884  2088             //       : mem_Alloc(...), mem_AllocV(...); or mem_AllocZ(...);
1885  2089             //       : returns 0 if function fails
1886  2090   
1887  2091             func mem_Heap(), 1;
1888  2092             // Syntax: myvar := heap();
1889  2093             // Usage : myvar := heap();
1890  2094             // Notes : returns bytecount available in heap
1891  2095             //       :
1892  2096   
1893  2097             func mem_Set("ptr","char","size"), 1;
1894  2098             // Syntax: mem_Set(ptr,char,bytesize);
1895  2099             // Usage : mem_Set(p, 'A', 100);
1896  2100             // Notes : fill a block of memory with a byte value
1897  2101             //       : returns ptr
1898  2102   
1899  2103             func mem_Copy("src","dest","count"), 1;
1900  2104             // Syntax: myvar := mem_Copy(src,dest,bytesize);
1901  2105             // Usage : myvar := mem_Copy(p1, p2, 100);
1902  2106             // Notes : copy a block of memory from src to dest
1903  2107             //       : returns src
1904  2108   
1905  2109             func mem_Compare("ptr1","ptr2","count"), 1;
1906  2110             // Syntax: myvar := mem_Compare(ptr1,ptr2,bytesize);
1907  2111             // Usage : myvar := mem_Compare(p1, p2, 100);
1908  2112             // Notes : compare blocks of memory at src, dest
1909  2113             //       : returns 0 if we have a match
1910  2114   
1911  2115             //------------------------------------------------------------------//
1912  2116             //        FAT16 Function Prototypes
1913  2117             //------------------------------------------------------------------//
1914  2118   
1915  2119             func file_Error(), 1;
1916  2120             // Syntax: myvar := file_Error();
1917  2121             // Usage : e := file_Error();
1918  2122             // Notes : return the most recent file error.
1919  2123             //       :
1920  2124   
1921  2125             func file_Count("filename"), 1;
1922  2126             // Syntax: count := file_Count("filename");
1923  2127             // Usage : count := file_Count("*.4dg");
1924  2128             // Notes : returns number of files found that match the criteria
1925  2129   
1926  2130             func file_Dir("filename"), 1;
1927  2131             // Syntax: count := file_Dir("filename");
1928  2132             // Usage : count := file_Dir("*.4dg");
1929  2133             // Notes : streams a string of filenames that agree with the search key
1930  2134             //       : returns number of files found that match the criteria
1931  2135   
1932  2136             func file_FindFirst("fname"), 1;
1933  2137             // Syntax: res := file_FindFirst("fname");
1934  2138             // Usage : if (file_FindFirst("*.4xe") ....
1935  2139             // Notes : returns true if at least 1 file exists
1936  2140             //       : that satisfies the file argument.
1937  2141             //       : Wildcards are usually used so if
1938  2142             //       : file_FindFirst returns true, further
1939  2143             //       : tests can be made using file_FindNext();
1940  2144             //       : to find all the files that match the
1941  2145             //       : wildcard class. Note that the stream behaviour
1942  2146             //       : is the same as file_Dir.
1943  2147             //       :
1944  2148   
1945  2149             func file_FindNext(), 1;
1946  2150             // Syntax: res := file_FindNext();
1947  2151             // Usage : while ((file_FindNext()) ....
1948  2152             // Notes : returns true if more file exists
1949  2153             //       : that satisfies the file argument
1950  2154             //       : that was given for  file_FindFirst.
1951  2155             //       : Wildcards must be used for
1952  2156             //       : file_FindFirst, else this function will
1953  2157             //       : always return zero as the only occurence
1954  2158             //       : will have already been found.
1955  2159             //       : Note that the stream behaviour
1956  2160             //       : is the same as file_Dir.
1957  2161             //       :
1958  2162   
1959  2163             func file_Exists("fname"), 1;
1960  2164             // Syntax: res := file_Exists("fname"),
1961  2165             // Usage : if(file_Exists("myfile") ....
1962  2166             // Notes : returns true if file exists
1963  2167             //       :
1964  2168   
1965  2169             func file_Open("fname", "mode"), 1;
1966  2170             // Syntax: handle := file_Open("fname","mode"),
1967  2171             // Usage : handle := file_Open("myfile.txt", 'r');
1968  2172             // Notes : returns handle if file exists
1969  2173             //       :
1970  2174   
1971  2175             func file_Close("handle"), 1;
1972  2176             // Syntax: res := file_Close("handle");
1973  2177             // Usage : res := file_Close(hnd1);
1974  2178             // Notes : returns true if file closed ok
1975  2179             //       :
1976  2180   
1977  2181             func file_Read("*dest", "size", "handle"), 1;
1978  2182             // Syntax: res := file_Read("*dest", "size", "handle"),
1979  2183             // Usage : res := file_Read(memblock,20,hnd1);
1980  2184             // Notes : returns number of characters read
1981  2185             //       : if "dest" is zero, data is read direct to GRAM window
1982  2186             //       :
1983  2187   
1984  2188   
1985  2189             func file_Seek("handle", "HiWord", "LoWord"), 1;
1986  2190             // Syntax: res := file_Seek("handle", "HiWord", "LoWord")
1987  2191             // Usage : res := file_Seek(hSource, 0, 0x1234);
1988  2192             // Notes : set file position to 0x00001234 (byte position 4660)
1989  2193             //       : for the file handle so subsequent data may be read
1990  2194             //       : from that position onwards with file_GetC(...),
1991  2195             //       : file_GetW(...) or file_GetS(...), or an image
1992  2196             //       : can be displayed with file_Image(...)
1993  2197             // Notes : returns true if ok, usually ignored
1994  2198   
1995  2199             func file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
1996  2200             // Syntax: file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
1997  2201             // Usage : res := file_Index(hsource, 0, 1000, 123), 1;
1998  2202             // Notes : set file seek position to 123000
1999  2203             //       : for the file handle so subsequent data may be read
2000  2204             //       : from that record position onwards with file_GetC(...),
2001  2205             //       : file_GetW(...) or file_GetS(...), or an image
2002  2206             //       : can be displayed with file_Image(...)
2003  2207             // Notes : returns true if ok, usually ignored
2004  2208   
2005  2209             func file_Tell("handle", "&HiWord", "&LoWord"), 1;
2006  2210             // Syntax: file_Tell("handle", &HiWord, &LoWord);
2007  2211             // Usage : file_Tell(fhndl, &SizeHi, &SizeLo);
2008  2212             // Notes : Reads the 32 bit file pointer and stores it into 2 variables.
2009  2213             //       : returns true if function succeeded
2010  2214   
2011  2215             func file_Write("*source", "size", "handle"), 1;
2012  2216             // Syntax: res := fwrite("*source", "size", "handle"),
2013  2217             // Usage : res := fwrite(memblock, 20, hnd1);
2014  2218             // Notes : returns number of bytes written
2015  2219             //       :
2016  2220   
2017  2221             func file_Size("handle", "&HiWord", "&LoWord"), 1;
2018  2222             // Syntax: file_Size("handle", &HiWord, &LoWord);
2019  2223             // Usage : file_Size(fhndl, &SizeHi, &SizeLo);
2020  2224             // Notes : Reads the 32 bit file size and stores it into 2 variables.
2021  2225             //       : returns true if function succeeded
2022  2226   
2023  2227             func file_Image("x", "y", "handle"), 1;
2024  2228             // Syntax: file_Image(x, y, handle);
2025  2229             // Usage : file_Image(10, 10, hnd1);
2026  2230             // Notes : Display an image from a file at the current file position.
2027  2231             //       : The image is displayed at x,y (with respect to top left corner).
2028  2232             //       : If there is more than 1 image in the file, it can be
2029  2233             //       : accessed with file_Seek(...)
2030  2234   
2031  2235             func file_ScreenCapture("x", "y", "width", "height", "handle"), 1;
2032  2236             // Syntax: file_ScreenCapture(x, y, w, h, handle);
2033  2237             // Usage : file_ScreenCapture(10, 10, 50,50, hnd1);
2034  2238             // Notes : Save a image from screen to file at the current file position.
2035  2239             //       : The image can later be displayed with file_Image(...);
2036  2240             //       : The file may be opened in append mode to accumulate multiple
2037  2241             //       : images. Later, the images can be accessed with file_Seek(...);
2038  2242             //       : Note that the image will be sector aligned.
2039  2243             //       : All image headers must start on a sector boundary.
2040  2244             //       : The image is saved from x, y (with respect to top left corner)
2041  2245             //       : and the capture area is determined by "width" and "height".
2042  2246             //       : returns 0 if function succeeded
2043  2247   
2044  2248             func file_PutC("char","handle"), 1;
2045  2249             // Syntax: file_PutC("char", "handle");
2046  2250             // Usage : file_PutC('x', hndl);
2047  2251             // Notes : returns true if function succeeded
2048  2252   
2049  2253             func file_GetC("handle"), 1;
2050  2254             // Syntax: file_GetC("handle");
2051  2255             // Usage : mychar := fgetC("handle");
2052  2256             // Notes : returns next char from file
2053  2257   
2054  2258             func file_PutW("word","handle"), 1;
2055  2259             // Syntax: file_PutW("word","handle");
2056  2260             // Usage : file_PutW(0x1234, hndl);
2057  2261             // Notes : returns true if function succeeded
2058  2262   
2059  2263             func file_GetW("handle"), 1;
2060  2264             // Syntax: file_GetW("handle");
2061  2265             // Usage : myword := fgetW("handle");
2062  2266             // Notes : returns next word in file
2063  2267   
2064  2268             func file_PutS("*source", "handle"), 1;
2065  2269             // Syntax: res := file_Puts("*source", "handle"),
2066  2270             // Usage : res := file_Puts(mystring, hnd1);
2067  2271             // Notes : returns number of characters written
2068  2272             //       :
2069  2273   
2070  2274             func file_GetS("*string", "size", "handle"), 1;
2071  2275             // Syntax: res := file_Gets("*string", "size", "handle");
2072  2276             // Usage : res := file_Gets(mystr , 81, hnd1); // read up to 80 chars
2073  2277             // Notes : get a string from a file
2074  2278             //       : returns pointer to string or null if failed.
2075  2279             //       : file_GetS(...) automatically appends a null-terminator to the data read.
2076  2280             //       : NB:- only reads up to "size-1" characters into "string"
2077  2281             //       : file_GetS(...) will stop reading when any of the following conditions are true:
2078  2282             //       : A] It has read n-1 bytes (one character is reserved for the null-terminator)
2079  2283             //       : B] It encounters a newline character (a line-feed in the compilers tested here), or
2080  2284             //       : C] It reaches the end of file
2081  2285             //       : D] A read error occurs.
2082  2286   
2083  2287   
2084  2288             func file_Erase("fname"), 1;
2085  2289             // Syntax: res := file_Erase("fname");
2086  2290             // Usage : res := file_Erase("myfile.txt");
2087  2291             // Notes : returns true if successful
2088  2292             //       :
2089  2293   
2090  2294             func file_Rewind("handle"), 1;
2091  2295             // Syntax: res := file_Rewind("handle");
2092  2296             // Usage : res := file_Rewind(hnd1);
2093  2297             // Notes : returns true if file rewound ok (usually ignored)
2094  2298             //       : resets the file pointer the the beginning of the open file.
2095  2299   
2096  2300             func file_LoadFunction("fname.4xe"), 1;
2097  2301             // Syntax: res := file_LoadFunction("fname.4fn");
2098  2302             // Usage : myfunc := file_LoadFunction(myfuncname);
2099  2303             // Notes : Load a function or program from disk and
2100  2304             //       : return a function pointer to the allocation.
2101  2305             //       : The function can then be invoked just like any other
2102  2306             //       : function would be called via a function pointer.
2103  2307             //       : Parameters may be passed to it in a conventional way.
2104  2308             //       : The function may be discarded at any time when no
2105  2309             //       : longer required, thus freeing its memory resources.
2106  2310             //       : The loaded function can be discarded with mem_Free(..)
2107  2311             //       : eg:
2108  2312             //       : popupWindow := file_LoadFunction("popupWindow1.4fn");
2109  2313             //       : if(!popupWindow) goto LoadFunctionFailed; // could not load the function !!!
2110  2314             //       : then elsewhere in your program:-
2111  2315             //       : res := popupWindow(MYMODE,"My Title","My Popup Text");
2112  2316             //       : if(res == QUIT_APPLICATION) goto exitApp;
2113  2317             //       : Later in your program, when popupWindow is no longer
2114  2318             //       : required for the application:-
2115  2319             //       : res := mem_Free(popupWindow);
2116  2320             //       : if(!res) goto FreeFunctionFailed; // should never happen if memory not corrupted
2117  2321             //       : The callers stack is shared by the loaded function,
2118  2322             //       : however any global variables in the loaded function
2119  2323             //       : are private to that function.
2120  2324             //
2121  2325   
2122  2326             func file_Run("fname.4xe", "arglistptr"), 1;
2123  2327             // Syntax: res := file_Run("fname.4xe","arglistptr");
2124  2328             // Usage : res := file_Run(fname, argptr);
2125  2329             // Notes : current program releases any allocated memory but
2126  2330             //       : retains the stack and global memory.
2127  2331             //       : If arglistptr is 0, no arguments are passed, else
2128  2332             //       : arglist points to an array, the first element being
2129  2333             //       : the number of elements in the array.
2130  2334             //       : func 'main' in the called program accepts
2131  2335             //       : the arguments, if any. THe arguments can only
2132  2336             //       : be passed by value, no pointers or references can be
2133  2337             //       : used as all memory is cleared before the file
2134  2338             //       : is loaded. Refer to file_Exec and file_LoadFunction
2135  2339             //       : for functions that can pass by reference.
2136  2340   
2137  2341             func file_Exec("fname.4xe", "arglistptr"), 1;
2138  2342             // Syntax: res := file_Exec("fname.4xe","arglistptr");
2139  2343             // Usage : res := file_Exec("fname.4xe","arglistptr");
2140  2344             // Notes : returns like a function, current program
2141  2345             //       : calling program is kept active and control returns to it.
2142  2346             //       : If arglistptr is 0, no arguments are passed, else
2143  2347             //       : arglist points to an array, the first element being
2144  2348             //       : the number of elements in the array.
2145  2349             //       : func 'main' in the called program accepts the arguments.
2146  2350             //       : This function is similar to file_LoadFunction(...), however,
2147  2351             //       : the function argument list is passed by pointer, and
2148  2352             //       : the memory consumed by the function is released as
2149  2353             //       : soon as the function completes.
2150  2354   
2151  2355             func file_LoadImageControl("fname1", "fname2", "mode"), 1;
2152  2356             // Syntax: hImagelist := file_LoadImageControl ("controlfile", "imagefile", "mode"),
2153  2357             // Usage : hImagelist := file_LoadImageControl ("resource.dat", "resource.gci", 0);
2154  2358             // Notes : Reads a control file to create an image list.
2155  2359             //       : Returns NULL if function fails.
2156  2360             //       : Returns a handle (pointer to the memory allocation) to the
2157  2361             //       : image control list that has been created.
2158  2362             //       : "fname1" is the control list filename "*.dat"
2159  2363             //       : "fname2" is the image filename "*.gci"
2160  2364   
2161  2365             // Notes : This function Calculates the size of a chunk of memory required for
2162  2366             //       : a image list and populates it from the image control file ("*.dat")
2163  2367             //       : therefore, when imagelist is no longer required, you must de-allocate
2164  2368             //       : the image list memory by using eg:- mem_Free(hImagelist);
2165  2369             //       : to restore the heap.
2166  2370             //       :
2167  2371             //       : mode 0:- it is assumed that there is a graphics file with the
2168  2372             //       : file extension "fname2.gci". In this case, the images have been stored
2169  2373             //       : in a FAT16 file concurrently, and the offsets that ar derived from the
2170  2374             //       : "fname1.dat" file are saved in the image control so that the image control
2171  2375             //       : can open the file (*.gci) and us file_Seek to get to the position of the
2172  2376             //       : image which can then automatically be displayed using file_Image(xpos, ypos, hSource);
2173  2377             //       : mode 0 builds the image control quickly as it only scans the *.dat file
2174  2378             //       : for the file offsets and save them in the relevant entries in the image control.
2175  2379             //       : The penalty is that images take longer to find when displayed due to file_Seek
2176  2380             //       : overheads.
2177  2381             //
2178  2382             //       : mode 1:- it is assumed that there is a graphics file with the
2179  2383             //       : file extension "fname2.gci". In this case, the images have been stored
2180  2384             //       : in a FAT16 file concurrently, and the offset of the images are saved
2181  2385             //       : in the image control so that image file (*.gci) can be mapped to directly.
2182  2386             //       : The absolute cluster/sector is mapped so file seek does not need to be called
2183  2387             //       : internally. This means that there is no seek time penalty, however, the
2184  2388             //       : image list takes a lot longer to build, as all the seeking is done at control
2185  2389             //       : build time.
2186  2390   
2187  2391             func file_Mount(), 1;
2188  2392             // Syntax: r := file_Mount();
2189  2393             // Usage : r := file_Mount();
2190  2394             // Notes : Create a control block for FAT16 and mount the File System
2191  2395   
2192  2396             func file_Unmount(), 0;
2193  2397             // Syntax: file_Unmount();
2194  2398             // Usage : file_Unmount();
2195  2399             // Notes : release any control block and buffers for FAT16
2196  2400             //       : and unmount the File System
2197  2401   
2198  2402             func file_PlayWAV("fname1"), 1;
2199  2403             // Syntax: file_PlayWAV("fname1");
2200  2404             // Usage : file_PlayWAV("ding.wav");
2201  2405             // Notes : Play a wave file with filename "fname1"
2202  2406             //       : This function automatically grabs a chunk
2203  2407             //       : of memory for a file buffer, and a wave
2204  2408             //       : buffer. The minimum memory requirement is
2205  2409             //       : about 580 bytes for the disk io service and
2206  2410             //       : a minimum wave buffer size of 1024. The siz
2207  2411             //       : of the wave buffer allocation
2208  2412             //       : can be increased by the snd_BufSize function.
2209  2413             //       : The default size 1024 bytes.
2210  2414             //       : NB the memory is only required during the
2211  2415             //       : duration of play, and is automatically
2212  2416             //       : released while not in use.
2213  2417             //       : See the Sound Class services for other associated controls.
2214  2418             //       : If there are no errors, returns number of blocks to play (1 to 32767)
2215  2419             //       : If errors occured, the folling is returned
2216  2420             //       : -6   : cant play this rate
2217  2421             //       : -5  : no data chunk found in first rsector
2218  2422             //       : -4  : no format data
2219  2423             //       : -3  : no wave chunk signature
2220  2424             //       : -2  : bad wave file format
2221  2425             //       : -1  : file not found
2222  2426   
2223  2427   
2224  2428   
2225  2429             //------------------------------------------------------------------//
2226  2430             //        Sound Class Services
2227  2431             //------------------------------------------------------------------//
2228  2432   
2229  2433             func snd_Volume("var"), 0;
2230  2434             // Syntax: snd_Volume("var");
2231  2435             // Usage : snd_Volume(30);
2232  2436             // Notes : set sound playback volume.  Var must
2233  2437             //       : be in the range from 8 (min volume)
2234  2438             //       : to 127 (max volume). If var is less
2235  2439             //       : than 8 volume is set to 8, and if
2236  2440             //       : var > 127 it is set to 127.
2237  2441   
2238  2442             func snd_Pitch("pitch"), 1;
2239  2443             // func snd_Pitch("freq"), 1;
2240  2444             // func snd_Pitch(7000), 1; // play the wave file with a sample frequency of 7khz
2241  2445             // Notes : sets the samples playback rate to a different frequency
2242  2446             //       : The minimum value is 4khz
2243  2447             //       : Setting the pitch to zero restores the original sample rate
2244  2448             //       : Return value is the samples original sample rate.
2245  2449   
2246  2450             func snd_BufSize("var"), 0;
2247  2451             // Syntax: snd_BufSize("var");
2248  2452             // Usage : snd_BufSize(2);
2249  2453             // Notes : specify the a memory chunk size for the wavefile buffer.
2250  2454             //       : default size 1024 bytes.
2251  2455             //       : 0 = 1024 bytes (default)
2252  2456             //       : 1 = 2048 bytes
2253  2457             //       : 2 = 4096 bytes
2254  2458             //       : 3 = 8192 bytes
2255  2459   
2256  2460             func snd_Stop(), 0;
2257  2461             // Syntax: snd_Stop();
2258  2462             // Usage : snd_Stop();
2259  2463             // Notes : stop any sound that is playing, releasing
2260  2464             //       : buffers and closes any open wav file.
2261  2465   
2262  2466             func snd_Pause(), 0;
2263  2467             // Syntax: snd_Pause();
2264  2468             // Usage : snd_Pause();
2265  2469             // Notes : pauses any sound that is playing, does nothing
2266  2470             //       : until sound is resumed with snd_Continue().
2267  2471             //       : The sample cam be terminated with snd_Stop.
2268  2472             //       : buffers and closes any open wav file.
2269  2473   
2270  2474             func snd_Continue(), 0;
2271  2475             // Syntax: snd_Continue();
2272  2476             // Usage : snd_Continue();
2273  2477             // Notes : resume any sound that is paused by snd_Pause.
2274  2478   
2275  2479             func snd_Playing(), 1;
2276  2480             // Syntax: snd_Playing();
2277  2481             // Usage : r := snd_Playing();
2278  2482             // Notes : returns 0 if sound has finished playing,
2279  2483             //       : else return number of 512 byte blocks to go.
2280  2484   
2281  2485   
2282  2486   
2283  2487             //------------------------------------------------------------------//
2284  2488             //        String Class Services
2285  2489             //------------------------------------------------------------------//
2286  2490   
2287  2491             func str_Ptr("&var"), 1;
2288  2492             // Syntax: str_Ptr(&var);
2289  2493             // Usage : p := str_Ptr(&var);
2290  2494             // Notes : return a byte pointer to a word region
2291  2495   
2292  2496             func str_GetD("&ptr", "&var"), 1;
2293  2497             // Syntax: str_GetD(&ptr, &var);
2294  2498             // Usage : ok := str_GetD(&ptr, &var);
2295  2499             // Notes : convert number in a string to DWORD ( myvar[2] )
2296  2500             //       : returns true if function succeeds, advancing ptr
2297  2501   
2298  2502             func str_GetW("&ptr", "&var"), 1;
2299  2503             // Syntax: str_GetW(&ptr, &var);
2300  2504             // Usage : ok := str_GetW(&ptr, &var);
2301  2505             // Notes : convert number in a string to WORD ( myvar )
2302  2506             //       : returns true if function succeeds, advancing ptr
2303  2507   
2304  2508             func str_GetHexW("&ptr", "&var"), 1;
2305  2509             // Syntax: str_GetHexW(&ptr, &var);
2306  2510             // Usage : ok := str_GetHexW(&ptr, &var);
2307  2511             // Notes : convert HEX number in a string to WORD ( myvar )
2308  2512             //       : returns true if function succeeds, advancing ptr
2309  2513   
2310  2514             func str_GetC("&ptr", "&var"), 1;
2311  2515             // Syntax: str_GetC(&ptr, &var);
2312  2516             // Usage : ok := str_GetC(&ptr, &var);
2313  2517             // Notes : get a valid ascii char in a string to WORD ( myvar )
2314  2518             //       : returns true if function succeeds, advancing ptr
2315  2519   
2316  2520             func str_GetByte("ptr"), 1;
2317  2521             // Syntax: str_GetByte(ptr);
2318  2522             // Usage : myvar := str_GetByte(ptr);
2319  2523             // Notes : get a byte to myvar
2320  2524             //       : returns value
2321  2525   
2322  2526             func str_GetWord("ptr"), 1;
2323  2527             // Syntax: GetWord(ptr);
2324  2528             // Usage : GetWord(ptr);
2325  2529             // Notes : get a word to myvar
2326  2530             //       : returns value
2327  2531   
2328  2532             func str_PutByte("ptr","val"), 0;
2329  2533             // Syntax: str_PutByte(ptr);
2330  2534             // Usage : myvar := str_PutByte(ptr);
2331  2535             // Notes : put a byte at ptr
2332  2536             //       : returns value
2333  2537   
2334  2538             func str_PutWord("ptr","val"), 0;
2335  2539             // Syntax: str_GetC(ptr);
2336  2540             // Usage : str_GetC(ptr);
2337  2541             // Notes : put a word at ptr
2338  2542             //       : returns value
2339  2543   
2340  2544             func str_Match("&ptr", "*str"), 1;
2341  2545             // Syntax: str_Match(&ptr, *str);
2342  2546             // Usage : r := str_Match(&p, "hello");
2343  2547             // Notes : Case sensitive match
2344  2548             //       : returns true if function succeded, andvancing pointer to position past
2345  2549             //       : the matched item. Note that any whitespace characters are skipped
2346  2550             //       : in the source string prior to the test.
2347  2551   
2348  2552             func str_MatchI("&ptr", "*str"), 1;
2349  2553             // Syntax: str_MatchI(&ptr, *str);
2350  2554             // Usage : r := str_MatchI(&p, "hello");
2351  2555             // Notes : Case insensitive match
2352  2556             //       : returns true if function succeded, andvancing pointer to position past
2353  2557             //       : the matched item. Note that any whitespace characters are skipped
2354  2558             //       : in the source string prior to the test.
2355  2559   
2356  2560             func str_Find("&ptr", "*str"), 1;
2357  2561             // Syntax: str_Find(&ptr, *str);
2358  2562             // Usage : n := str_Find(&p, "hello");
2359  2563             // Notes : given the address of a pointer to a source string as the
2360  2564             //       : first argument, and a pointer to a test string as the second
2361  2565             //       : argument, attempt to find the position of the matching string
2362  2566             //       : in the source string. The test is performed with case sensitivity.
2363  2567             //       : return 0 if not found, else returns the address of the first
2364  2568             //       : character of the match. NB:- The source pointer is not altered.
2365  2569   
2366  2570             func str_FindI("&ptr", "*str"), 1;
2367  2571             // Syntax: str_Find(&ptr, *str);
2368  2572             // Usage : n := str_Find(&p, "hello");
2369  2573             // Notes : given the address of a pointer to a source string as the
2370  2574             //       : first argument, and a pointer to a test string as the second
2371  2575             //       : argument, attempt to find the position of the matching string
2372  2576             //       : in the source string. The test is performed with no case
2373  2577             //       : sensitivity, eg upper and lower case chars are accepted.
2374  2578             //       : return 0 if not found, else returns the address of the first
2375  2579             //       : character of the match. NB:- The source pointer is not altered.
2376  2580   
2377  2581             func str_Length("ptr"), 1;
2378  2582             // Syntax: str_Length(ptr);
2379  2583             // Usage : len := str_Ptr(mystring);
2380  2584             // Notes : return the length of a string excluding terminator
2381  2585   
2382  2586             func str_Printf("&ptr", "*format"), 1;
2383  2587             // Syntax: str_Printf("&ptr", "*format");
2384  2588             // Usage : r := str_Printf(&p, "hello");
2385  2589             // Notes : refer to documentation
2386  2590             //       :
2387  2591   
2388  2592             func str_Cat("&dest","&src"), 1;
2389  2593             // Syntax: str_Append("&dest","&src");
2390  2594             // Usage : str_Append(&buf,"Hello");
2391  2595             // Notes : Appends a copy of the source string to the destination string.
2392  2596             //       : The terminating null character in destination is overwritten by
2393  2597             //       : the first character of source, and a new null-character is appended
2394  2598             //       : at the end of the new string formed by the concatenation of both in destination.
2395  2599             //       : returns destination.
2396  2600   
2397  2601             func str_CatN("&ptr","str","count"), 1;
2398  2602             // Syntax: str_Append("&dest","&src","count");
2399  2603             // Usage : str_Append(&buf,"Monday",3);
2400  2604             // Notes : Appends a copy of the source string to the destination string.
2401  2605             //       : The number of characters copied is limited by "count".
2402  2606             //       : The terminating null character in destination is overwritten by
2403  2607             //       : the first character of source, and a new null-character is appended
2404  2608             //       : at the end of the new string formed by the concatenation of both in destination.
2405  2609             //       : returns destination.
2406  2610   
2407  2611   
2408  2612             func sys_StoreTouchCalibration(), 1;
2409  2613             // Syntax: sys_StoreTouchCalibration();
2410  2614             // Usage : r := sys_StoreTouchCalibration();
2411  2615             // Notes : Store the touch calibration values in non-volatile memory.
2412  2616             //       : Returns true if the values have been accepted and stored,
2413  2617             //       : else returns false if write could not be performed, or
2414  2618             //       : touch calibration values are improbable.
2415  2619             //       : The values that are stored are obtained from:-
2416  2620             //	 : TOUCH_XMINCAL             78  // touch calibration value
2417  2621             //	 : TOUCH_YMINCAL             79  // touch calibration value
2418  2622             //       : TOUCH_XMAXCAL             80  // touch calibration value
2419  2623             //       : TOUCH_YMAXCAL             81  // touch calibration value
2420  2624             //       : refer to the 4DGL example touchCalibrate.4DG for further information.
2421  2625   
2422  2626   
2423  2627             //------------------------------------------------------------------//
2424  2628             // CONSTANTS
2425  2629             //------------------------------------------------------------------//
2426  2630   
2427  2631             // generic constants
2428  2632             #CONST
2429  2641             #END
2430  2642   
2431  2643             //------------------------------------------------------------------------------
2432  2644             // Pin related constants
2433  2645             //------------------------------------------------------------------------------
2434  2646             #CONST
2435  2656             #END
2436  2657   
2437  2658             //------------------------------------------------------------------------------
2438  2659             //gfx_Set() related constants
2439  2660             //------------------------------------------------------------------------------
2440  2661             #CONST
2441  2678             #END
2442  2679   
2443  2680   
2444  2681             #CONST
2445  2694             #END
2446  2695   
2447  2696   
2448  2697             #CONST
2449  2720             #END
2450  2721   
2451  2722             //------------------------------------------------------------------------------
2452  2723             //txt_Set() related constants
2453  2724             //------------------------------------------------------------------------------
2454  2725             #CONST
2455  2744             #END
2456  2745   
2457  2746   
2458  2747   
2459  2748             //------------------------------------------------------------------------------
2460  2749             //txt_Set() related arguments
2461  2750             // NB:- FONT4 must be inherited if required,
2462  2751             // eg #inherit "FONT4.fnt"
2463  2752             //------------------------------------------------------------------------------
2464  2753             #CONST
2465  2765             #END
2466  2766   
2467  2767   
2468  2768   
2469  2769             //gfx_Get() related constants
2470  2770             #CONST
2471  2777             #END
2472  2778   
2473  2779   
2474  2780             //touch_Set() related constants
2475  2781             #CONST
2476  2785             #END
2477  2786   
2478  2787             //touch_Get() related constants
2479  2788             #CONST
2480  2796             #END
2481  2797   
2482  2798             // image control offset related constants
2483  2799             #CONST
2484  2806             #END
2485  2807   
2486  2808             // image attribute flags
2487  2809             // for img_SetAttributes(...) and img_ClearAttributes(...)
2488  2810             #CONST
2489  2824             #END
2490  2825   
2491  2826   
2492  2827             #constant ALL 0xFFFF // argument for img_xxx functions to update all images
2493  2827             #constant ALL 0xFFFF // argument for img_xxx functions to update all images
2494  2828   
2495  2829             // image control entry offsets
2496  2830             #CONST
2497  2845             #END
2498  2846   
2499  2847             #CONST
2500  2865             #END
2501  2866   
2502  2867   
2503  2868   
2504  2869   
2505  2870             #CONST
2506  2890             #END
2507  2891   
2508  2892   
2509  2893   
2510  2894             // timer control  related constants
2511  2895             #CONST
2512  2904             #END
2513  2905   
2514  2906             // I2C timing related constants
2515  2907             #CONST
2516  2911             #END
2517  2912   
2518  2913   
2519  2914   
2520  2915   
2521  2916             //------------------------------------------------------------------------------
2522  2917             // system WORD variables accesible with peekW and pokeW or pointer access
2523  2918             // Note that the txt_Set variables (0-15) and gfx_set variables (16-31)
2524  2919             // can also be accessed with peekW and pokeW
2525  2920             //------------------------------------------------------------------------------
2526  2921   
2527  2922             #CONST
2528  3014             #END
2529  3015   
2530  3016             //------------------------------------------------------------------------------
2531  3017             // FILEIO Error Code Constants
2532  3018             //------------------------------------------------------------------------------
2533  3019             #CONST
2534  3044             #END
2535  3045   
2536  3046             //==================================================================================================
2537  3047   
2538  3048   
2539  3049   
2540  0013                 #ENDIF
2541  0014   
2542  0015   
2543  0016                 #CONST
2544  0072                 #END
2545  0073   
2546  0074   
2547  0075             //===========================================================================================
2548  0076   
2549  0077   
2550  0002   
2551  0011             */
2552  0012   
file C:\Program Files (x86)\4D Labs\4D Workshop 3 IDE\include\4DGL_16bitColours.fnc

2553  0013             #inherit "4DGL_16bitColours.fnc"
2554  0013             #inherit "4DGL_16bitColours.fnc"
2555  0004             */
2556  0005   
2557  0006   
2558  0007   
2559  0008             #CONST
2560  0149             #END
2561  0150   
2562  0014   
2563  0015   
2564  0016             #constant RADIUS 110
2565  0016             #constant RADIUS 110
2566  0017             #constant CENTER 120
2567  0017             #constant CENTER 120
2568  0018   
2569  0019             #constant V 0
2570  0019             #constant V 0
2571  0020             #constant C 1
2572  0020             #constant C 1
2573  0021   
2574  0022             #constant START_CHAR 0x55
2575  0022             #constant START_CHAR 0x55
2576  0023             #constant END_CHAR 0xAA
2577  0023             #constant END_CHAR 0xAA
2578  0024   
2579  0025             #constant SEND_GAUGE_VALUE 0
2580  0025             #constant SEND_GAUGE_VALUE 0
2581  0026             #constant SET_GAUGE_TITLE 1
2582  0026             #constant SET_GAUGE_TITLE 1
2583  0027             #constant SET_GAUGE_MAX 2
2584  0027             #constant SET_GAUGE_MAX 2
2585  0028   
2586  0029   
2587  0030   
2588  0031             //Necessary Globals
2589  0032             var oldNeedleAngle;
2590  0033   
2591  0034             //serial buffer (Local arrays not supported in this release of the compiler)
2592  0035             var combuf[10];    // 1 var = 2 bytes
2593  0036             var databuf[10];
2594  0037   
2595  0038             var inputVoltage;
2596  0039   
2597  0040             var maxValue;
2598  0041   
2599  0042   
2600  0043             // draw the line for a gauge hand
2601  0044             func DrawNeedle(var length, var angle, var color)
2602  0045                 var targetX, targetY;
2603  0046   
2604  0047                 gfx_Set(OBJECT_COLOUR, color);
2605  0048                 gfx_MoveTo(CENTER, CENTER);             // reset the centrpoint
2606  0049                 gfx_OrbitInit(&targetX, &targetY);      // target variables
2607  0050                 gfx_Orbit(angle, length);
2608  0051                 gfx_Line(CENTER, CENTER, targetX, targetY, color);
2609  0052   
2610  0053             endfunc
2611  0054   
2612  0055             //clear old needle value, draw new needle, draw text
2613  0056             func DrawNeedleValue(var value, var max, var DP)
2614  0057                 var k;
2615  0058                 var tempAngle;
2616  0059   
2617  0060                 k := 30000 / max;                     // needle step ratio
2618  0061   
2619  0062                 tempAngle := value * k;
2620  0063   
2621  0064                 tempAngle := tempAngle / 100;
2622  0065   
2623  0066                 tempAngle := tempAngle - 240;       //start at beginning of gauge
2624  0067   
2625  0068                 if(oldNeedleAngle != tempAngle)
2626  0069   
2627  0070                     DrawNeedle(RADIUS-5, oldNeedleAngle, BLACK); //clear old needle
2628  0071                     DrawNeedle(RADIUS-5, tempAngle, WHITE);      //write new needle
2629  0072                     oldNeedleAngle := tempAngle;
2630  0073   
2631  0074                 endif
2632  0075   
2633  0076                 gfx_Set(PEN_SIZE, 0);
2634  0077                 gfx_Circle( CENTER, CENTER, 5, WHITE ); //redraw centre circle
2635  0078   
2636  0079                 txt_FGcolour(WHITE);
2637  0080                 gfx_MoveTo(105, 175);
2638  0081   
2639  0082                 if(DP == 0)
2640  0083                     print([UDEC4Z]value,"\n");                  // show current value on gauge
2641  0084                 else if(DP == 1)
2642  0085                     print([UDEC3Z]value/10,".",[UDEC1Z]value%10);
2643  0086                 else if(DP == 3)
2644  0087                     gfx_MoveTo(45, 35);
2645  0088                     print([UDEC2Z]value/1000,".",[UDEC3Z]value%1000);
2646  0089   
2647  0090                 endif
2648  0091   
2649  0092   
2650  0093             endfunc
2651  0094   
2652  0095   
2653  0096             func DrawGaugeFace()
2654  0097                 var n,k;
2655  0098                 var x1, y1, x2, y2;
2656  0099                 var colr;
2657  0100   
2658  0101                 gfx_Cls();
2659  0102   
2660  0103                 gfx_Set(PEN_SIZE, 1);
2661  0104                 gfx_Circle(CENTER, CENTER, RADIUS, WHITE );
2662  0105   
2663  0106                 gfx_MoveTo(CENTER, CENTER);
2664  0107   
2665  0108                 n := -90;                                   // 12 o'clock position
2666  0109                 while (n<270)
2667  0110                     gfx_OrbitInit(&x2, &y2);            // outer target
2668  0111                     gfx_Orbit(n, RADIUS);                    // store the position
2669  0112   
2670  0113                     if (n >= 0 && n < 60)
2671  0114                             k := RADIUS-5;
2672  0115                             colr := RED;
2673  0116                     else if(n >= -90 && n < 0)
2674  0117                             k := RADIUS-4;
2675  0118                             colr := ORANGE;
2676  0119                     else if(n >= 120 && n < 270)
2677  0120                             k := RADIUS-3;
2678  0121                             colr := YELLOW;
2679  0122                     endif
2680  0123   
2681  0124                     gfx_OrbitInit(&x1, &y1);            // inner target
2682  0125                     gfx_Orbit(n, k);                    // store the position
2683  0126   
2684  0127                     gfx_Line(x1,y1,x2,y2,colr);
2685  0128                     n := n + 30;                        // mark each 30 degreees
2686  0129                 wend
2687  0130   
2688  0131                 gfx_Set(PEN_SIZE, 0);
2689  0132                 gfx_Rectangle(0, 116, 128, 128, BLACK);
2690  0133   
2691  0134             endfunc
2692  0135   
2693  0136   
2694  0137   
2695  0138             func main()
2696  0139   
2697  0140                 var secl;
2698  0141                 var len;
2699  0142                 var i;
2700  0143                 var command;
2701  0144                 var value;
2702  0145                 var dataisgood;
2703  0146   
2704  0147   
2705  0148                 setbaud(BAUD_115200);
2706  0149                 DrawGaugeFace();
2707  0150                 DrawNeedleValue(0, 255, 0);
2708  0151   
2709  0152              //   pin_Set(ANALOGUE_8, 0);
2710  0153   
2711  0154              //   pin_HI(1);
2712  0155   
2713  0156                 repeat
2714  0157                     com_Init(combuf, 10, 0);
2715  0158                     pause(20);
2716  0159   
2717  0160                     if(com_Count() > 0)
2718  0161   
2719  0162                         secl := serin();
2720  0163                         if(secl == START_CHAR)
2721  0164                             command := serin();
2722  0165                             len := serin();
2723  0166                             i := 0;
2724  0167                             while(i < len)
2725  0168                                 databuf[i] := serin();
2726  0169                                 i := i + 1;
2727  0170                             wend
2728  0171                             secl := serin();
2729  0172   
2730  0173                             dataisgood := 0;
2731  0174                             if(secl == END_CHAR)
2732  0175                                 dataisgood := 1;
2733  0176                             else
2734  0177                                 dataisgood := 0;
2735  0178                             endif
2736  0179   
2737  0180                         endif
2738  0181                     endif
2739  0182   
2740  0183   
2741  0184   
2742  0185   
2743  0186                     if(dataisgood == 1)
2744  0187   
2745  0188                         if(command == SEND_GAUGE_VALUE)
2746  0189   
2747  0190                             i := 0;
2748  0191                             value := 0;
2749  0192                             if (len == 1)
2750  0193                                 value := databuf[0];
2751  0194                             else if(len == 2)
2752  0195                                 value := databuf[1];
2753  0196                                 value := value + databuf[0] * 256;
2754  0197                             endif
2755  0198   
2756  0199                             DrawNeedleValue(value, maxValue, 0);
2757  0200                                 //com_Init(combuf, 10, 0);
2758  0201                         else if(command == SET_GAUGE_TITLE)
2759  0202   
2760  0203                             gfx_MoveTo(50, 110);
2761  0204                             i := 0;
2762  0205                             while(i < len)
2763  0206                                 print([CHR] databuf[i]);
2764  0207                                 i := i + 1;
2765  0208                             wend
2766  0209                         else if(command == SET_GAUGE_MAX)
2767  0210   
2768  0211                             maxValue := databuf[0] * 256;
2769  0212                             maxValue := maxValue + databuf[1];
2770  0213   
2771  0214                         endif
2772  0215   
2773  0216                     endif
2774  0217   
2775  0218   
2776  0219                     //Auto shut off routine:
2777  0220             //        inputVoltage := pin_Read(0);
2778  0221             //        if(inputVoltage < 40)
2779  0222             //            gfx_Set(CONTRAST, 0);
2780  0223             //            pin_LO(1);
2781  0224             //        endif
2782  0225   
2783  0226   
2784  0227   
2785  0228                 forever
2786  0229   
2787  0230             endfunc
2788  0231             //==================================================================================================
2789  0232   
2790  0233   


Symbol Table:
name                 decimal    hex
__MAXMEM                           14336  0x00003800 (const dword)  (usage 1)
__MAXPROG                          15360  0x00003c00 (const dword)  (usage 1)
BAUD_115200                           13  0x0000000d (const dword)  (usage 1)
BLACK                                  0  0x00000000 (const dword)  (usage 2)
CENTER                               120  0x00000078 (const dword)  (usage 10)
CHR                                  129  0x00000081 (const dword)  (usage 1)
com_Count                           -122  0xffffff86 (PmmC func) args[0] r=1  (usage 1)
com_Init                            -120  0xffffff88 (PmmC func) args[3] r=0  (usage 1)
combuf                                 2  0x00000002 (mem) word[10] (global)  (usage 1)
databuf                               22  0x00000016 (mem) word[10] (global)  (usage 7)
DrawGaugeFace                        356  0x00000164 (User func) args[0] r=0  (usage 1)
DrawNeedle                           892  0x0000037c (User func) args[3] r=0  (usage 2)
DrawNeedleValue                      620  0x0000026c (User func) args[3] r=0  (usage 2)
END_CHAR                             170  0x000000aa (const dword)  (usage 1)
gfx_Circle                           -61  0xffffffc3 (PmmC func) args[4] r=0  (usage 2)
gfx_Cls                              -51  0xffffffcd (PmmC func) args[0] r=0  (usage 1)
gfx_Line                             -56  0xffffffc8 (PmmC func) args[5] r=0  (usage 2)
gfx_MoveTo                           -52  0xffffffcc (PmmC func) args[2] r=0  (usage 5)
gfx_Orbit                            -67  0xffffffbd (PmmC func) args[2] r=0  (usage 3)
gfx_OrbitInit                        -66  0xffffffbe (PmmC func) args[2] r=0  (usage 3)
gfx_Rectangle                        -59  0xffffffc5 (PmmC func) args[5] r=0  (usage 1)
gfx_Set                              -50  0xffffffce (PmmC func) args[2] r=0  (usage 4)
maxValue                              44  0x0000002c (mem) word (global)  (usage 4)
OBJECT_COLOUR                         18  0x00000012 (const dword)  (usage 1)
oldNeedleAngle                         0  0x00000000 (mem) word (global)  (usage 3)
ORANGE                             64800  0x0000fd20 (const dword)  (usage 1)
pause                                 -6  0xfffffffa (PmmC func) args[1] r=0  (usage 1)
PEN_SIZE                              16  0x00000010 (const dword)  (usage 3)
PICASO                                 1  0x00000001 (const dword)  (usage 1)
RADIUS                               110  0x0000006e (const dword)  (usage 7)
RED                                63488  0x0000f800 (const dword)  (usage 1)
SEND_GAUGE_VALUE                       0  0x00000000 (const dword)  (usage 1)
serin                                 -1  0xffffffff (PmmC func) args[0] r=1  (usage 5)
SET_GAUGE_MAX                          2  0x00000002 (const dword)  (usage 1)
SET_GAUGE_TITLE                        1  0x00000001 (const dword)  (usage 1)
setbaud                               -4  0xfffffffc (PmmC func) args[1] r=0  (usage 1)
START_CHAR                            85  0x00000055 (const dword)  (usage 1)
txt_FGcolour                         -25  0xffffffe7 (PmmC func) args[1] r=1  (usage 1)
UDEC1Z                             20746  0x0000510a (const dword)  (usage 1)
UDEC2Z                             21002  0x0000520a (const dword)  (usage 1)
UDEC3Z                             21258  0x0000530a (const dword)  (usage 2)
UDEC4Z                             21514  0x0000540a (const dword)  (usage 1)
WHITE                              65535  0x0000ffff (const dword)  (usage 4)
YELLOW                             65504  0x0000ffe0 (const dword)  (usage 1)
